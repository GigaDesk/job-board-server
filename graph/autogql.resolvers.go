// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"context"
	"fmt"
	"strings"

	"github.com/GigaDesk/eardrum-server/graph/db"
	"github.com/GigaDesk/eardrum-server/graph/model"
	"github.com/fasibio/autogql/runtimehelper"
	"github.com/huandu/xstrings"
	"gorm.io/gorm/clause"
)

// GetAdmin is the resolver for the getAdmin field.
func (r *queryResolver) GetAdmin(ctx context.Context, id int) (*model.Admin, error) {
	v, okHook := r.Sql.Hooks[string(db.GetAdmin)].(db.AutoGqlHookGet[model.Admin, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "Admin"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.Admin
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Admin")
	db = db.First(&res, tableName+".id = ?", id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryAdmin is the resolver for the queryAdmin field.
func (r *queryResolver) QueryAdmin(ctx context.Context, filter *model.AdminFiltersInput, order *model.AdminOrder, first *int, offset *int, group []model.AdminGroup) (*model.AdminQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryAdmin)].(db.AutoGqlHookQuery[model.Admin, model.AdminFiltersInput, model.AdminOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.Admin
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Admin")
	preloadSubTables := runtimehelper.GetPreloadsMap(ctx, "data").SubTables
	if len(preloadSubTables) > 0 {
		db = runtimehelper.GetPreloadSelection(ctx, db, preloadSubTables[0])
	}
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	if len(group) > 0 {
		garr := make([]string, len(group))
		for i, g := range group {
			garr[i] = fmt.Sprintf("%s.%s", tableName, xstrings.ToSnakeCase(string(g)))
		}
		db = db.Group(strings.Join(garr, ","))
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.AdminQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddAdminPayload() AddAdminPayloadResolver {
	return &adminPayloadResolver[*model.AddAdminPayload]{r}
}
func (r *Resolver) DeleteAdminPayload() DeleteAdminPayloadResolver {
	return &adminPayloadResolver[*model.DeleteAdminPayload]{r}
}
func (r *Resolver) UpdateAdminPayload() UpdateAdminPayloadResolver {
	return &adminPayloadResolver[*model.UpdateAdminPayload]{r}
}

type adminPayload interface {
	*model.AddAdminPayload | *model.DeleteAdminPayload | *model.UpdateAdminPayload
}

type adminPayloadResolver[T adminPayload] struct {
	*Resolver
}

func (r *adminPayloadResolver[T]) Admin(ctx context.Context, obj T, filter *model.AdminFiltersInput, order *model.AdminOrder, first *int, offset *int, group []model.AdminGroup) (*model.AdminQueryResult, error) {
	q := r.Query().(*queryResolver)
	return q.QueryAdmin(ctx, filter, order, first, offset, group)
}

// AddAdmin is the resolver for the addAdmin field.
func (r *mutationResolver) AddAdmin(ctx context.Context, input []*model.AdminInput) (*model.AddAdminPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddAdmin)].(db.AutoGqlHookAdd[model.Admin, model.AdminInput, model.AddAdminPayload])
	res := &model.AddAdminPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.Admin, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	affectedRes := make([]*model.Admin, len(obj))
	for i, v := range obj {
		tmp := v
		affectedRes[i] = &tmp
	}
	res.Affected = affectedRes
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateAdmin is the resolver for the updateAdmin field.
func (r *mutationResolver) UpdateAdmin(ctx context.Context, input model.UpdateAdminInput) (*model.UpdateAdminPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateAdmin)].(db.AutoGqlHookUpdate[model.UpdateAdminInput, model.UpdateAdminPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Admin")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Admin{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Admin
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	affectedRes := make([]*model.Admin, 0)
	subTables := runtimehelper.GetPreloadsMap(ctx, "affected").SubTables
	if len(subTables) > 0 {
		if preloadMap := subTables[0]; len(preloadMap.Fields) > 0 {
			affectedDb := runtimehelper.GetPreloadSelection(ctx, db, preloadMap)
			affectedDb = affectedDb.Model(&obj)
			affectedDb.Find(&affectedRes)
		}
	}

	res := &model.UpdateAdminPayload{
		Count:    int(db.RowsAffected),
		Affected: affectedRes,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteAdmin is the resolver for the deleteAdmin field.
func (r *mutationResolver) DeleteAdmin(ctx context.Context, filter model.AdminFiltersInput) (*model.DeleteAdminPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteAdmin)].(db.AutoGqlHookDelete[model.AdminFiltersInput, model.DeleteAdminPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Admin")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Admin{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Admin
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteAdminPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetEmployer is the resolver for the getEmployer field.
func (r *queryResolver) GetEmployer(ctx context.Context, id int) (*model.Employer, error) {
	v, okHook := r.Sql.Hooks[string(db.GetEmployer)].(db.AutoGqlHookGet[model.Employer, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "Employer"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.Employer
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Employer")
	db = db.First(&res, tableName+".id = ?", id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryEmployer is the resolver for the queryEmployer field.
func (r *queryResolver) QueryEmployer(ctx context.Context, filter *model.EmployerFiltersInput, order *model.EmployerOrder, first *int, offset *int, group []model.EmployerGroup) (*model.EmployerQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryEmployer)].(db.AutoGqlHookQuery[model.Employer, model.EmployerFiltersInput, model.EmployerOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.Employer
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Employer")
	preloadSubTables := runtimehelper.GetPreloadsMap(ctx, "data").SubTables
	if len(preloadSubTables) > 0 {
		db = runtimehelper.GetPreloadSelection(ctx, db, preloadSubTables[0])
	}
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	if len(group) > 0 {
		garr := make([]string, len(group))
		for i, g := range group {
			garr[i] = fmt.Sprintf("%s.%s", tableName, xstrings.ToSnakeCase(string(g)))
		}
		db = db.Group(strings.Join(garr, ","))
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.EmployerQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddEmployerPayload() AddEmployerPayloadResolver {
	return &employerPayloadResolver[*model.AddEmployerPayload]{r}
}
func (r *Resolver) DeleteEmployerPayload() DeleteEmployerPayloadResolver {
	return &employerPayloadResolver[*model.DeleteEmployerPayload]{r}
}
func (r *Resolver) UpdateEmployerPayload() UpdateEmployerPayloadResolver {
	return &employerPayloadResolver[*model.UpdateEmployerPayload]{r}
}

type employerPayload interface {
	*model.AddEmployerPayload | *model.DeleteEmployerPayload | *model.UpdateEmployerPayload
}

type employerPayloadResolver[T employerPayload] struct {
	*Resolver
}

func (r *employerPayloadResolver[T]) Employer(ctx context.Context, obj T, filter *model.EmployerFiltersInput, order *model.EmployerOrder, first *int, offset *int, group []model.EmployerGroup) (*model.EmployerQueryResult, error) {
	q := r.Query().(*queryResolver)
	return q.QueryEmployer(ctx, filter, order, first, offset, group)
}

// AddEmployer is the resolver for the addEmployer field.
func (r *mutationResolver) AddEmployer(ctx context.Context, input []*model.EmployerInput) (*model.AddEmployerPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddEmployer)].(db.AutoGqlHookAdd[model.Employer, model.EmployerInput, model.AddEmployerPayload])
	res := &model.AddEmployerPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.Employer, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	affectedRes := make([]*model.Employer, len(obj))
	for i, v := range obj {
		tmp := v
		affectedRes[i] = &tmp
	}
	res.Affected = affectedRes
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateEmployer is the resolver for the updateEmployer field.
func (r *mutationResolver) UpdateEmployer(ctx context.Context, input model.UpdateEmployerInput) (*model.UpdateEmployerPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateEmployer)].(db.AutoGqlHookUpdate[model.UpdateEmployerInput, model.UpdateEmployerPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Employer")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Employer{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Employer
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	affectedRes := make([]*model.Employer, 0)
	subTables := runtimehelper.GetPreloadsMap(ctx, "affected").SubTables
	if len(subTables) > 0 {
		if preloadMap := subTables[0]; len(preloadMap.Fields) > 0 {
			affectedDb := runtimehelper.GetPreloadSelection(ctx, db, preloadMap)
			affectedDb = affectedDb.Model(&obj)
			affectedDb.Find(&affectedRes)
		}
	}

	res := &model.UpdateEmployerPayload{
		Count:    int(db.RowsAffected),
		Affected: affectedRes,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteEmployer is the resolver for the deleteEmployer field.
func (r *mutationResolver) DeleteEmployer(ctx context.Context, filter model.EmployerFiltersInput) (*model.DeleteEmployerPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteEmployer)].(db.AutoGqlHookDelete[model.EmployerFiltersInput, model.DeleteEmployerPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Employer")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Employer{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Employer
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteEmployerPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetJob is the resolver for the getJob field.
func (r *queryResolver) GetJob(ctx context.Context, id int) (*model.Job, error) {
	v, okHook := r.Sql.Hooks[string(db.GetJob)].(db.AutoGqlHookGet[model.Job, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "Job"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.Job
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Job")
	db = db.First(&res, tableName+".id = ?", id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryJob is the resolver for the queryJob field.
func (r *queryResolver) QueryJob(ctx context.Context, filter *model.JobFiltersInput, order *model.JobOrder, first *int, offset *int, group []model.JobGroup) (*model.JobQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryJob)].(db.AutoGqlHookQuery[model.Job, model.JobFiltersInput, model.JobOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.Job
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Job")
	preloadSubTables := runtimehelper.GetPreloadsMap(ctx, "data").SubTables
	if len(preloadSubTables) > 0 {
		db = runtimehelper.GetPreloadSelection(ctx, db, preloadSubTables[0])
	}
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	if len(group) > 0 {
		garr := make([]string, len(group))
		for i, g := range group {
			garr[i] = fmt.Sprintf("%s.%s", tableName, xstrings.ToSnakeCase(string(g)))
		}
		db = db.Group(strings.Join(garr, ","))
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.JobQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddJobPayload() AddJobPayloadResolver {
	return &jobPayloadResolver[*model.AddJobPayload]{r}
}
func (r *Resolver) DeleteJobPayload() DeleteJobPayloadResolver {
	return &jobPayloadResolver[*model.DeleteJobPayload]{r}
}
func (r *Resolver) UpdateJobPayload() UpdateJobPayloadResolver {
	return &jobPayloadResolver[*model.UpdateJobPayload]{r}
}

type jobPayload interface {
	*model.AddJobPayload | *model.DeleteJobPayload | *model.UpdateJobPayload
}

type jobPayloadResolver[T jobPayload] struct {
	*Resolver
}

func (r *jobPayloadResolver[T]) Job(ctx context.Context, obj T, filter *model.JobFiltersInput, order *model.JobOrder, first *int, offset *int, group []model.JobGroup) (*model.JobQueryResult, error) {
	q := r.Query().(*queryResolver)
	return q.QueryJob(ctx, filter, order, first, offset, group)
}

// AddJob is the resolver for the addJob field.
func (r *mutationResolver) AddJob(ctx context.Context, input []*model.JobInput) (*model.AddJobPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddJob)].(db.AutoGqlHookAdd[model.Job, model.JobInput, model.AddJobPayload])
	res := &model.AddJobPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.Job, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	affectedRes := make([]*model.Job, len(obj))
	for i, v := range obj {
		tmp := v
		affectedRes[i] = &tmp
	}
	res.Affected = affectedRes
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateJob is the resolver for the updateJob field.
func (r *mutationResolver) UpdateJob(ctx context.Context, input model.UpdateJobInput) (*model.UpdateJobPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateJob)].(db.AutoGqlHookUpdate[model.UpdateJobInput, model.UpdateJobPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Job")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Job{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Job
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	affectedRes := make([]*model.Job, 0)
	subTables := runtimehelper.GetPreloadsMap(ctx, "affected").SubTables
	if len(subTables) > 0 {
		if preloadMap := subTables[0]; len(preloadMap.Fields) > 0 {
			affectedDb := runtimehelper.GetPreloadSelection(ctx, db, preloadMap)
			affectedDb = affectedDb.Model(&obj)
			affectedDb.Find(&affectedRes)
		}
	}

	res := &model.UpdateJobPayload{
		Count:    int(db.RowsAffected),
		Affected: affectedRes,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteJob is the resolver for the deleteJob field.
func (r *mutationResolver) DeleteJob(ctx context.Context, filter model.JobFiltersInput) (*model.DeleteJobPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteJob)].(db.AutoGqlHookDelete[model.JobFiltersInput, model.DeleteJobPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Job")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Job{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Job
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteJobPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetUnapprovedJob is the resolver for the getUnapprovedJob field.
func (r *queryResolver) GetUnapprovedJob(ctx context.Context, id int) (*model.UnapprovedJob, error) {
	v, okHook := r.Sql.Hooks[string(db.GetUnapprovedJob)].(db.AutoGqlHookGet[model.UnapprovedJob, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "UnapprovedJob"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.UnapprovedJob
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("UnapprovedJob")
	db = db.First(&res, tableName+".id = ?", id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryUnapprovedJob is the resolver for the queryUnapprovedJob field.
func (r *queryResolver) QueryUnapprovedJob(ctx context.Context, filter *model.UnapprovedJobFiltersInput, order *model.UnapprovedJobOrder, first *int, offset *int, group []model.UnapprovedJobGroup) (*model.UnapprovedJobQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryUnapprovedJob)].(db.AutoGqlHookQuery[model.UnapprovedJob, model.UnapprovedJobFiltersInput, model.UnapprovedJobOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.UnapprovedJob
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("UnapprovedJob")
	preloadSubTables := runtimehelper.GetPreloadsMap(ctx, "data").SubTables
	if len(preloadSubTables) > 0 {
		db = runtimehelper.GetPreloadSelection(ctx, db, preloadSubTables[0])
	}
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	if len(group) > 0 {
		garr := make([]string, len(group))
		for i, g := range group {
			garr[i] = fmt.Sprintf("%s.%s", tableName, xstrings.ToSnakeCase(string(g)))
		}
		db = db.Group(strings.Join(garr, ","))
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.UnapprovedJobQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddUnapprovedJobPayload() AddUnapprovedJobPayloadResolver {
	return &unapprovedJobPayloadResolver[*model.AddUnapprovedJobPayload]{r}
}
func (r *Resolver) DeleteUnapprovedJobPayload() DeleteUnapprovedJobPayloadResolver {
	return &unapprovedJobPayloadResolver[*model.DeleteUnapprovedJobPayload]{r}
}
func (r *Resolver) UpdateUnapprovedJobPayload() UpdateUnapprovedJobPayloadResolver {
	return &unapprovedJobPayloadResolver[*model.UpdateUnapprovedJobPayload]{r}
}

type unapprovedJobPayload interface {
	*model.AddUnapprovedJobPayload | *model.DeleteUnapprovedJobPayload | *model.UpdateUnapprovedJobPayload
}

type unapprovedJobPayloadResolver[T unapprovedJobPayload] struct {
	*Resolver
}

func (r *unapprovedJobPayloadResolver[T]) UnapprovedJob(ctx context.Context, obj T, filter *model.UnapprovedJobFiltersInput, order *model.UnapprovedJobOrder, first *int, offset *int, group []model.UnapprovedJobGroup) (*model.UnapprovedJobQueryResult, error) {
	q := r.Query().(*queryResolver)
	return q.QueryUnapprovedJob(ctx, filter, order, first, offset, group)
}

// AddUnapprovedJob is the resolver for the addUnapprovedJob field.
func (r *mutationResolver) AddUnapprovedJob(ctx context.Context, input []*model.UnapprovedJobInput) (*model.AddUnapprovedJobPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddUnapprovedJob)].(db.AutoGqlHookAdd[model.UnapprovedJob, model.UnapprovedJobInput, model.AddUnapprovedJobPayload])
	res := &model.AddUnapprovedJobPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.UnapprovedJob, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	affectedRes := make([]*model.UnapprovedJob, len(obj))
	for i, v := range obj {
		tmp := v
		affectedRes[i] = &tmp
	}
	res.Affected = affectedRes
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateUnapprovedJob is the resolver for the updateUnapprovedJob field.
func (r *mutationResolver) UpdateUnapprovedJob(ctx context.Context, input model.UpdateUnapprovedJobInput) (*model.UpdateUnapprovedJobPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateUnapprovedJob)].(db.AutoGqlHookUpdate[model.UpdateUnapprovedJobInput, model.UpdateUnapprovedJobPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("UnapprovedJob")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.UnapprovedJob{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.UnapprovedJob
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	affectedRes := make([]*model.UnapprovedJob, 0)
	subTables := runtimehelper.GetPreloadsMap(ctx, "affected").SubTables
	if len(subTables) > 0 {
		if preloadMap := subTables[0]; len(preloadMap.Fields) > 0 {
			affectedDb := runtimehelper.GetPreloadSelection(ctx, db, preloadMap)
			affectedDb = affectedDb.Model(&obj)
			affectedDb.Find(&affectedRes)
		}
	}

	res := &model.UpdateUnapprovedJobPayload{
		Count:    int(db.RowsAffected),
		Affected: affectedRes,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteUnapprovedJob is the resolver for the deleteUnapprovedJob field.
func (r *mutationResolver) DeleteUnapprovedJob(ctx context.Context, filter model.UnapprovedJobFiltersInput) (*model.DeleteUnapprovedJobPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteUnapprovedJob)].(db.AutoGqlHookDelete[model.UnapprovedJobFiltersInput, model.DeleteUnapprovedJobPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("UnapprovedJob")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.UnapprovedJob{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.UnapprovedJob
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteUnapprovedJobPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetUnverifiedAdmin is the resolver for the getUnverifiedAdmin field.
func (r *queryResolver) GetUnverifiedAdmin(ctx context.Context, id int) (*model.UnverifiedAdmin, error) {
	v, okHook := r.Sql.Hooks[string(db.GetUnverifiedAdmin)].(db.AutoGqlHookGet[model.UnverifiedAdmin, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "UnverifiedAdmin"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.UnverifiedAdmin
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("UnverifiedAdmin")
	db = db.First(&res, tableName+".id = ?", id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryUnverifiedAdmin is the resolver for the queryUnverifiedAdmin field.
func (r *queryResolver) QueryUnverifiedAdmin(ctx context.Context, filter *model.UnverifiedAdminFiltersInput, order *model.UnverifiedAdminOrder, first *int, offset *int, group []model.UnverifiedAdminGroup) (*model.UnverifiedAdminQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryUnverifiedAdmin)].(db.AutoGqlHookQuery[model.UnverifiedAdmin, model.UnverifiedAdminFiltersInput, model.UnverifiedAdminOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.UnverifiedAdmin
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("UnverifiedAdmin")
	preloadSubTables := runtimehelper.GetPreloadsMap(ctx, "data").SubTables
	if len(preloadSubTables) > 0 {
		db = runtimehelper.GetPreloadSelection(ctx, db, preloadSubTables[0])
	}
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	if len(group) > 0 {
		garr := make([]string, len(group))
		for i, g := range group {
			garr[i] = fmt.Sprintf("%s.%s", tableName, xstrings.ToSnakeCase(string(g)))
		}
		db = db.Group(strings.Join(garr, ","))
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.UnverifiedAdminQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddUnverifiedAdminPayload() AddUnverifiedAdminPayloadResolver {
	return &unverifiedAdminPayloadResolver[*model.AddUnverifiedAdminPayload]{r}
}
func (r *Resolver) DeleteUnverifiedAdminPayload() DeleteUnverifiedAdminPayloadResolver {
	return &unverifiedAdminPayloadResolver[*model.DeleteUnverifiedAdminPayload]{r}
}
func (r *Resolver) UpdateUnverifiedAdminPayload() UpdateUnverifiedAdminPayloadResolver {
	return &unverifiedAdminPayloadResolver[*model.UpdateUnverifiedAdminPayload]{r}
}

type unverifiedAdminPayload interface {
	*model.AddUnverifiedAdminPayload | *model.DeleteUnverifiedAdminPayload | *model.UpdateUnverifiedAdminPayload
}

type unverifiedAdminPayloadResolver[T unverifiedAdminPayload] struct {
	*Resolver
}

func (r *unverifiedAdminPayloadResolver[T]) UnverifiedAdmin(ctx context.Context, obj T, filter *model.UnverifiedAdminFiltersInput, order *model.UnverifiedAdminOrder, first *int, offset *int, group []model.UnverifiedAdminGroup) (*model.UnverifiedAdminQueryResult, error) {
	q := r.Query().(*queryResolver)
	return q.QueryUnverifiedAdmin(ctx, filter, order, first, offset, group)
}

// AddUnverifiedAdmin is the resolver for the addUnverifiedAdmin field.
func (r *mutationResolver) AddUnverifiedAdmin(ctx context.Context, input []*model.UnverifiedAdminInput) (*model.AddUnverifiedAdminPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddUnverifiedAdmin)].(db.AutoGqlHookAdd[model.UnverifiedAdmin, model.UnverifiedAdminInput, model.AddUnverifiedAdminPayload])
	res := &model.AddUnverifiedAdminPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.UnverifiedAdmin, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	affectedRes := make([]*model.UnverifiedAdmin, len(obj))
	for i, v := range obj {
		tmp := v
		affectedRes[i] = &tmp
	}
	res.Affected = affectedRes
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateUnverifiedAdmin is the resolver for the updateUnverifiedAdmin field.
func (r *mutationResolver) UpdateUnverifiedAdmin(ctx context.Context, input model.UpdateUnverifiedAdminInput) (*model.UpdateUnverifiedAdminPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateUnverifiedAdmin)].(db.AutoGqlHookUpdate[model.UpdateUnverifiedAdminInput, model.UpdateUnverifiedAdminPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("UnverifiedAdmin")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.UnverifiedAdmin{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.UnverifiedAdmin
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	affectedRes := make([]*model.UnverifiedAdmin, 0)
	subTables := runtimehelper.GetPreloadsMap(ctx, "affected").SubTables
	if len(subTables) > 0 {
		if preloadMap := subTables[0]; len(preloadMap.Fields) > 0 {
			affectedDb := runtimehelper.GetPreloadSelection(ctx, db, preloadMap)
			affectedDb = affectedDb.Model(&obj)
			affectedDb.Find(&affectedRes)
		}
	}

	res := &model.UpdateUnverifiedAdminPayload{
		Count:    int(db.RowsAffected),
		Affected: affectedRes,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteUnverifiedAdmin is the resolver for the deleteUnverifiedAdmin field.
func (r *mutationResolver) DeleteUnverifiedAdmin(ctx context.Context, filter model.UnverifiedAdminFiltersInput) (*model.DeleteUnverifiedAdminPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteUnverifiedAdmin)].(db.AutoGqlHookDelete[model.UnverifiedAdminFiltersInput, model.DeleteUnverifiedAdminPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("UnverifiedAdmin")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.UnverifiedAdmin{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.UnverifiedAdmin
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteUnverifiedAdminPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetUnverifiedEmployer is the resolver for the getUnverifiedEmployer field.
func (r *queryResolver) GetUnverifiedEmployer(ctx context.Context, id int) (*model.UnverifiedEmployer, error) {
	v, okHook := r.Sql.Hooks[string(db.GetUnverifiedEmployer)].(db.AutoGqlHookGet[model.UnverifiedEmployer, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "UnverifiedEmployer"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.UnverifiedEmployer
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("UnverifiedEmployer")
	db = db.First(&res, tableName+".id = ?", id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryUnverifiedEmployer is the resolver for the queryUnverifiedEmployer field.
func (r *queryResolver) QueryUnverifiedEmployer(ctx context.Context, filter *model.UnverifiedEmployerFiltersInput, order *model.UnverifiedEmployerOrder, first *int, offset *int, group []model.UnverifiedEmployerGroup) (*model.UnverifiedEmployerQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryUnverifiedEmployer)].(db.AutoGqlHookQuery[model.UnverifiedEmployer, model.UnverifiedEmployerFiltersInput, model.UnverifiedEmployerOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.UnverifiedEmployer
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("UnverifiedEmployer")
	preloadSubTables := runtimehelper.GetPreloadsMap(ctx, "data").SubTables
	if len(preloadSubTables) > 0 {
		db = runtimehelper.GetPreloadSelection(ctx, db, preloadSubTables[0])
	}
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	if len(group) > 0 {
		garr := make([]string, len(group))
		for i, g := range group {
			garr[i] = fmt.Sprintf("%s.%s", tableName, xstrings.ToSnakeCase(string(g)))
		}
		db = db.Group(strings.Join(garr, ","))
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.UnverifiedEmployerQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddUnverifiedEmployerPayload() AddUnverifiedEmployerPayloadResolver {
	return &unverifiedEmployerPayloadResolver[*model.AddUnverifiedEmployerPayload]{r}
}
func (r *Resolver) DeleteUnverifiedEmployerPayload() DeleteUnverifiedEmployerPayloadResolver {
	return &unverifiedEmployerPayloadResolver[*model.DeleteUnverifiedEmployerPayload]{r}
}
func (r *Resolver) UpdateUnverifiedEmployerPayload() UpdateUnverifiedEmployerPayloadResolver {
	return &unverifiedEmployerPayloadResolver[*model.UpdateUnverifiedEmployerPayload]{r}
}

type unverifiedEmployerPayload interface {
	*model.AddUnverifiedEmployerPayload | *model.DeleteUnverifiedEmployerPayload | *model.UpdateUnverifiedEmployerPayload
}

type unverifiedEmployerPayloadResolver[T unverifiedEmployerPayload] struct {
	*Resolver
}

func (r *unverifiedEmployerPayloadResolver[T]) UnverifiedEmployer(ctx context.Context, obj T, filter *model.UnverifiedEmployerFiltersInput, order *model.UnverifiedEmployerOrder, first *int, offset *int, group []model.UnverifiedEmployerGroup) (*model.UnverifiedEmployerQueryResult, error) {
	q := r.Query().(*queryResolver)
	return q.QueryUnverifiedEmployer(ctx, filter, order, first, offset, group)
}

// AddUnverifiedEmployer is the resolver for the addUnverifiedEmployer field.
func (r *mutationResolver) AddUnverifiedEmployer(ctx context.Context, input []*model.UnverifiedEmployerInput) (*model.AddUnverifiedEmployerPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddUnverifiedEmployer)].(db.AutoGqlHookAdd[model.UnverifiedEmployer, model.UnverifiedEmployerInput, model.AddUnverifiedEmployerPayload])
	res := &model.AddUnverifiedEmployerPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.UnverifiedEmployer, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	affectedRes := make([]*model.UnverifiedEmployer, len(obj))
	for i, v := range obj {
		tmp := v
		affectedRes[i] = &tmp
	}
	res.Affected = affectedRes
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateUnverifiedEmployer is the resolver for the updateUnverifiedEmployer field.
func (r *mutationResolver) UpdateUnverifiedEmployer(ctx context.Context, input model.UpdateUnverifiedEmployerInput) (*model.UpdateUnverifiedEmployerPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateUnverifiedEmployer)].(db.AutoGqlHookUpdate[model.UpdateUnverifiedEmployerInput, model.UpdateUnverifiedEmployerPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("UnverifiedEmployer")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.UnverifiedEmployer{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.UnverifiedEmployer
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	affectedRes := make([]*model.UnverifiedEmployer, 0)
	subTables := runtimehelper.GetPreloadsMap(ctx, "affected").SubTables
	if len(subTables) > 0 {
		if preloadMap := subTables[0]; len(preloadMap.Fields) > 0 {
			affectedDb := runtimehelper.GetPreloadSelection(ctx, db, preloadMap)
			affectedDb = affectedDb.Model(&obj)
			affectedDb.Find(&affectedRes)
		}
	}

	res := &model.UpdateUnverifiedEmployerPayload{
		Count:    int(db.RowsAffected),
		Affected: affectedRes,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteUnverifiedEmployer is the resolver for the deleteUnverifiedEmployer field.
func (r *mutationResolver) DeleteUnverifiedEmployer(ctx context.Context, filter model.UnverifiedEmployerFiltersInput) (*model.DeleteUnverifiedEmployerPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteUnverifiedEmployer)].(db.AutoGqlHookDelete[model.UnverifiedEmployerFiltersInput, model.DeleteUnverifiedEmployerPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("UnverifiedEmployer")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.UnverifiedEmployer{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.UnverifiedEmployer
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteUnverifiedEmployerPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}
