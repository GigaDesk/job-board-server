package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"errors"
	"fmt"
	"strconv"

	"github.com/GigaDesk/eardrum-prefix/validate"
	"github.com/GigaDesk/eardrum-server/auth"
	"github.com/GigaDesk/eardrum-server/encrypt"
	"github.com/GigaDesk/eardrum-server/graph/model"
	"github.com/GigaDesk/eardrum-server/phoneutils"
	"github.com/GigaDesk/eardrum-server/pkg/jwt"
	"github.com/GigaDesk/eardrum-server/shutdown"
	"github.com/rs/zerolog/log"
)

// CreateEmployee is the resolver for the createEmployee field.
func (r *mutationResolver) CreateEmployee(ctx context.Context, input model.NewEmployee) (*model.UnverifiedEmployee, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate inputs
	if err := input.Validate(); err != nil {
		return nil, err
	}

	//check if the phone number exists in the database
	phoneexists, err := phoneutils.CheckEmployeePhoneNumber(r.Sql.Db, input.PhoneNumber)

	//return any error that might be associated with checking the phone number's existence in the database
	if err != nil {
		log.Error().Str("phone_number", input.PhoneNumber).Str("path", "CreateEmployee").Msg(err.Error())
		return nil, errors.New("error checking phone number's existence")
	}

	//return an error if phone number exists in the database
	if phoneexists.Verified == true || phoneexists.Unverified == true {
		return nil, errors.New("phone number already exists")
	}

	//encrypt input password
	encryptedpassword, err := encrypt.HashPassword(input.Password)
	if err != nil {
		log.Error().Str("password", input.Password).Str("path", "CreateEmployee").Msg(err.Error())
		return nil, err
	}
	//create an unverified employee data
	unverifiedemployee := &model.UnverifiedEmployee{
		Name:           input.Name,
		PhoneNumber:    input.PhoneNumber,
		Password:       encryptedpassword,
		Profilepicture: input.Profilepicture,
	}

	/*send an OTP code to the phone number associated with the unverified employee record, return error if there is any
	if err := phoneutils.SendOtp(unverifiedemployee.PhoneNumber); err != nil {
		log.Error().Str("phone_number", input.PhoneNumber).Str("path", "CreateEmployee").Msg(err.Error())
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/

	//create an unverified employee record in the database and return if operation succeeds
	if err := r.Sql.Db.Create(unverifiedemployee).Error; err != nil {
		log.Error().Str("name", input.Name).Str("path", "CreateEmployee").Msg(err.Error())
		return nil, errors.New("an unexpected error occurred while creating the employee account. please try again later or contact support")
	}

	return unverifiedemployee, nil
}

// VerifyEmployee is the resolver for the verifyEmployee field.
func (r *mutationResolver) VerifyEmployee(ctx context.Context, input model.Verificationinfo) (*model.Employee, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate inputs
	if err := input.Validate(); err != nil {
		return nil, err
	}

	/*Check the validity of an OTP code
	if err := phoneutils.CheckOtp(input.PhoneNumber, input.Otp); err != nil {
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/
	if input.Otp != "777777" {
		return nil, errors.New("incorrect OTP code")
	}
	//declare an unverifiedemployee variable
	var unverifiedemployee *model.UnverifiedEmployee

	// Find the first unverified employee that matches the input phone number from the unverified employee table
	if err := r.Sql.Db.Where("phone_number = ?", input.PhoneNumber).First(&unverifiedemployee).Error; err != nil {
		log.Info().Str("phone_number", input.PhoneNumber).Str("path", "VerifyEmployee").Msg("phone number does not exist")
		return nil, errors.New("error finding unverified employee with phone number: " + input.PhoneNumber)
	}

	// transform the unverified employee model into employee model and copy it
	employee := &model.Employee{
		Name:           unverifiedemployee.Name,
		PhoneNumber:    unverifiedemployee.PhoneNumber,
		Password:       unverifiedemployee.Password,
		Profilepicture: unverifiedemployee.Profilepicture,
	}

	// take the newly transformed and copied employee data and transfer it into the official verified employee table
	if err := r.Sql.Db.Create(employee).Error; err != nil {
		log.Info().Str("name", employee.Name).Str("path", "VerifyEmployee").Msg(err.Error())
		return nil, errors.New("Failed to verify employee account. please try again later or contact support")
	}

	// delete the unverified employee from the unverified employee table
	if err := r.Sql.Db.Delete(unverifiedemployee).Error; err != nil {
		log.Error().Str("path", "VerifyEmployee").Int("record_id", unverifiedemployee.ID).Msg(err.Error())
		return nil, errors.New("Failed to complete employee account verification. please try again later or contact support")
	}

	log.Info().Int("initial_record_id", unverifiedemployee.ID).Int("final_record_id", employee.ID).Str("path", "VerifyEmployee").Msg("completed unverified employee to employee data transaction")
	return employee, nil
}

// EmployeeLogin is the resolver for the employeeLogin field.
func (r *mutationResolver) EmployeeLogin(ctx context.Context, input model.EmployeeLogin) (*string, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	//validate EmployeeLogin input
	if err := input.Validate(); err != nil {
		return nil, err
	}

	//declare an employee variable
	var employee *model.Employee
	// Find the first employee that matches the input phone number from the employee table

	if err := r.Sql.Db.Where("phone_number = ?", input.PhoneNumber).First(&employee).Error; err != nil {
		log.Info().Str("phone_number", input.PhoneNumber).Str("path", "EmployeeLogin").Msg(err.Error())
		return nil, errors.New("phone number does not exist")
	}
	//check if the password of the employee matches the input password
	if err := encrypt.CheckPassword(employee.Password, input.Password); err != nil {
		log.Info().Str("path", "EmployeeLogin").Msg(err.Error())
		return nil, errors.New("Invalid phone number or password")
	}

	credentials := jwt.TokenCredentials{
		Id:   strconv.Itoa(employee.ID),
		Role: "employee",
	}
	token, err := jwt.GenerateToken(credentials)
	if err != nil {
		log.Error().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "EmployeeLogin").Msg(err.Error())
		return nil, errors.New("error generating accessToken")
	}
	log.Info().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "EmployeeLogin").Msg("employee logged in successfully!")
	return &token, nil
}

// ForgotEmployeePassword is the resolver for the forgotEmployeePassword field.
func (r *mutationResolver) ForgotEmployeePassword(ctx context.Context, phoneNumber string) (*model.SendCodeStatus, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	//validate phone number
	if err := validate.ValidateKenyanPhoneNumber(phoneNumber); err != nil {
		return nil, err
	}

	//check if the phone number exists in the database
	phoneexists, err := phoneutils.CheckEmployeePhoneNumber(r.Sql.Db, phoneNumber)

	//return any error that might be associated with checking the phone number's existence in the database
	if err != nil {
		log.Error().Str("phone_number", phoneNumber).Str("path", "ForgotEmployeePassword").Msg(err.Error())
		return nil, err
	}
	//return an error if phone number exists in the unverified employee table
	if phoneexists.Verified != true && phoneexists.Unverified == true {
		return nil, errors.New("phone number has been registered but is yet to be verified")
	}
	//return an error if phone number is neither registered nor verified
	if phoneexists.Verified != true && phoneexists.Unverified != true {
		return nil, errors.New("phone number does not exist")
	}
	/*send an OTP code to the phone number provided, return error if there is any
	if err := phoneutils.SendOtp(phoneNumber); err != nil {
		log.Error().Str("phone_number", phoneNumber).Str("path", "ForgotEmployeePassword").Msg(err.Error())
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/
	//return status on success
	sendcodestatus := &model.SendCodeStatus{
		PhoneNumber: phoneNumber,
		Success:     true,
	}
	return sendcodestatus, nil
}

// RequestEmployeePasswordReset is the resolver for the requestEmployeePasswordReset field.
func (r *mutationResolver) RequestEmployeePasswordReset(ctx context.Context, input *model.Verificationinfo) (*string, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate inputs
	if err := input.Validate(); err != nil {
		return nil, err
	}

	/*Check the validity of an OTP code
	if err := phoneutils.CheckOtp(input.PhoneNumber, input.Otp); err != nil {
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/
	if input.Otp != "777777" {
		return nil, errors.New("incorrect OTP code")
	}

	//declare an employee variable
	var employee *model.Employee

	// Find the first employee that matches the input phone number from the employee table

	if err := r.Sql.Db.Where("phone_number = ?", input.PhoneNumber).First(&employee).Error; err != nil {
		log.Info().Str("phone_number", input.PhoneNumber).Str("path", "RequestEmployeePasswordReset").Msg(err.Error())
		return nil, errors.New("phone number does not exist")
	}

	credentials := jwt.TokenCredentials{
		Id:   strconv.Itoa(employee.ID),
		Role: "employee",
	}
	token, err := jwt.GenerateToken(credentials)
	if err != nil {
		log.Error().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "RequestEmployeePasswordReset").Msg(err.Error())
		return nil, errors.New("error generating accessToken")
	}
	return &token, nil
}

// ResetEmployeePassword is the resolver for the resetEmployeePassword field.
func (r *mutationResolver) ResetEmployeePassword(ctx context.Context, newPassword string) (*model.Employee, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	user, err := auth.ForContext(ctx)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, errors.New("access to reset employee password denied!")
	}
	role := user.GetRole()
	if role != "employee" {
		return nil, errors.New("access to reset employee password denied. Only available for registered and logged in employees. To fix check access token!")
	}
	id, err := user.GetID()

	if err != nil {
		errors.New("could not access employee's id!")
	}

	//validate inputs
	if err := validate.ValidatePassword(newPassword); err != nil {
		return nil, err
	}

	var employee *model.Employee
	//fetch the record to be updated from the database
	if err := r.Sql.Db.First(&employee, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "ResetEmployeePassword").Msg(err.Error())
		return nil, err
	}
	//encrypt input password
	encryptedpassword, err := encrypt.HashPassword(newPassword)
	if err != nil {
		log.Error().Str("password", newPassword).Str("path", "ResetEmployeePassword").Msg(err.Error())
		return nil, err
	}
	// Update the records' attributes with `map`
	if err := r.Sql.Db.Model(&employee).Updates(map[string]interface{}{"password": encryptedpassword}).Error; err != nil {
		log.Error().Int("id", employee.ID).Str("path", "ResetEmployeePassword").Msg(fmt.Sprintf("updating employee password failed: %s", err.Error()))
		return nil, err
	}

	//fetch the record again from the database, this time the updated version
	if err := r.Sql.Db.First(&employee, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "ResetEmployeePassword").Msg(err.Error())
		return nil, err
	}

	//return the updated record
	return employee, nil
}

// EmployeePhoneNumberExists is the resolver for the employeePhoneNumberExists field.
func (r *queryResolver) EmployeePhoneNumberExists(ctx context.Context, phoneNumber string) (*model.PhoneNumberExists, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	phoneexists, err := phoneutils.CheckEmployeePhoneNumber(r.Sql.Db, phoneNumber)

	if err != nil {
		log.Error().Str("phone_number", phoneNumber).Str("path", "EmployeePhoneNumberExists").Msg(err.Error())
		return nil, err
	}

	return phoneexists, nil
}

// GetEmployeeProfile is the resolver for the getEmployeeProfile field.
func (r *queryResolver) GetEmployeeProfile(ctx context.Context) (*model.EmployeeProfile, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	user, err := auth.ForContext(ctx)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, errors.New("access to get employee profile denied!")
	}
	role := user.GetRole()
	if role != "employee" {
		return nil, errors.New("access to get employee profile denied. Only available for registered and logged in employees. To fix check access token!")
	}
	id, err := user.GetID()

	if err != nil {
		errors.New("could not access employee's id!")
	}

	var employee *model.Employee

	if err := r.Sql.Db.First(&employee, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "GetEmployeeProfile").Msg(err.Error())
		return nil, errors.New("could not access employee's profile!")
	}

	log.Info().Int("id", id).Str("role", role).Str("path", "GetEmployeeProfile").Msg("getting employee's profile")

	employeeprofile := &model.EmployeeProfile{
		ID:             employee.ID,
		CreatedAt:      employee.CreatedAt,
		UpdatedAt:      employee.UpdatedAt,
		Name:           employee.Name,
		PhoneNumber:    employee.PhoneNumber,
		Profilepicture: employee.Profilepicture,
	}
	return employeeprofile, nil
}

// GetEmployeesProfile is the resolver for the getEmployeesProfile field.
func (r *queryResolver) GetEmployeesProfile(ctx context.Context) ([]*model.EmployeeProfile, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	var employees []*model.Employee
	if err := r.Sql.Db.Find(&employees).Error; err != nil {
		log.Error().Str("path", "GetEmployeesProfile").Msg(err.Error())
		return nil, errors.New("could not access employees' profile!")
	}
	log.Info().Str("path", "GetEmployeesProfile").Msg("getting employees' profile")

	var employeesprofile []*model.EmployeeProfile

	for _, employee := range employees {
		employeeprofile := &model.EmployeeProfile{
			ID:             employee.ID,
			CreatedAt:      employee.CreatedAt,
			UpdatedAt:      employee.UpdatedAt,
			Name:           employee.Name,
			PhoneNumber:    employee.PhoneNumber,
			Profilepicture: employee.Profilepicture,
		}
		employeesprofile = append(employeesprofile, employeeprofile)
	}

	return employeesprofile, nil
}
