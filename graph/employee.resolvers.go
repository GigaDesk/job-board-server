package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/GigaDesk/eardrum-prefix/validate"
	"github.com/GigaDesk/eardrum-server/auth"
	"github.com/GigaDesk/eardrum-server/encrypt"
	"github.com/GigaDesk/eardrum-server/graph/model"
	"github.com/GigaDesk/eardrum-server/phoneutils"
	"github.com/GigaDesk/eardrum-server/pkg/jwt"
	"github.com/GigaDesk/eardrum-server/shutdown"
	"github.com/rs/zerolog/log"
)

// Applications is the resolver for the applications field.
func (r *employeeProfileResolver) Applications(ctx context.Context, obj *model.EmployeeProfile, status *model.ApplicationStatus) ([]*model.ApplicationProfile, error) {
	var applications []model.Application

	query := status.Query(r.Sql.Db.Model(&model.Application{}))

	if err := query.Where("employee_id = ?", obj.ID).Find(&applications).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("could not access applications!")
	}
	var applicationprofiles []*model.ApplicationProfile

	for _, application := range applications {
		applicationprofile := &model.ApplicationProfile{
			ID:             application.ID,
			CreatedAt:      application.CreatedAt,
			UpdatedAt:      application.UpdatedAt,
			DeletedAt:      application.DeletedAt,
			EducationLevel: application.EducationLevel,
			Experience:     application.Experience,
			CoverLetterURL: application.CoverLetterURL,
			ResumeeURL:     application.ResumeeURL,
			Status:         model.ApplicationStatus(strings.ToUpper(application.Status)),
		}
		applicationprofiles = append(applicationprofiles, applicationprofile)
	}

	return applicationprofiles, nil
}

// Analytics is the resolver for the analytics field.
func (r *employeeProfileResolver) Analytics(ctx context.Context, obj *model.EmployeeProfile) (*model.EmployeeAnalytics, error) {
	var total_applications int64

	if err := r.Sql.Db.Model(&model.Application{}).Where("employee_id = ?", obj.ID).Count(&total_applications).Error; err != nil {
		log.Error().Int("employee_id", obj.ID).Msg(err.Error())
		return nil, errors.New("error counting total applications")
	}
	var accepted_applications int64

	if err := r.Sql.Db.Model(&model.Application{}).Where("employee_id = ?", obj.ID).Where("status = ?", "accepted").Count(&accepted_applications).Error; err != nil {
		log.Error().Int("employee_id", obj.ID).Msg(err.Error())
		return nil, errors.New("error counting accepted applications")
	}

	var rejected_applications int64

	if err := r.Sql.Db.Model(&model.Application{}).Where("employee_id = ?", obj.ID).Where("status = ?", "rejected").Count(&rejected_applications).Error; err != nil {
		log.Error().Int("employee_id", obj.ID).Msg(err.Error())
		return nil, errors.New("error counting rejected applications")
	}

	var pending_applications int64

	if err := r.Sql.Db.Model(&model.Application{}).Where("employee_id = ?", obj.ID).Where("status = ?", "pending").Count(&pending_applications).Error; err != nil {
		log.Error().Int("employee_id", obj.ID).Msg(err.Error())
		return nil, errors.New("error counting pending applications")
	}

	applications_analytics := model.ApplicationAnalytics{
		Total:    int(total_applications),
		Accepted: int(accepted_applications),
		Rejected: int(rejected_applications),
		Pending:  int(pending_applications),
	}

	var applications []model.Application

	if err := r.Sql.Db.Where("employee_id = ?", obj.ID).Find(&applications).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("could not access applications!")
	}

	var jobIds []int

	for _, application := range applications {
		jobIds = append(jobIds, application.JobID)
	}

	var diploma_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("id IN ?", jobIds).Where("education_level = ?", "Diploma").Count(&diploma_jobs).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("error counting diploma jobs!")
	}

	var bachelors_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("id IN ?", jobIds).Where("education_level = ?", "Bachelor's Degree").Count(&bachelors_jobs).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("error counting bachelors jobs!")
	}

	var masters_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("id IN ?", jobIds).Where("education_level = ?", "Master's Degree").Count(&masters_jobs).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("error counting masters jobs!")
	}

	var phd_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("id IN ?", jobIds).Where("education_level = ?", "PhD").Count(&phd_jobs).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("error counting phd jobs!")
	}

	job_education_level_analytics := model.JobEducationLevelAnalytics{
		Diploma:         int(diploma_jobs),
		BachelorsDegree: int(bachelors_jobs),
		MastersDegree:   int(masters_jobs),
		Phd:             int(phd_jobs),
		Unspecified:     len(jobIds) - int(diploma_jobs) - int(bachelors_jobs) - int(masters_jobs) - int(phd_jobs),
	}

	var beginner_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("id IN ?", jobIds).Where("level = ?", "Beginner").Count(&beginner_jobs).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("error counting beginner jobs!")
	}

	var intermediate_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("id IN ?", jobIds).Where("level = ?", "Intermediate").Count(&intermediate_jobs).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("error counting intermediate jobs!")
	}

	var senior_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("id IN ?", jobIds).Where("level = ?", "Senior").Count(&senior_jobs).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("error counting senior jobs!")
	}

	job_seniority_level_analytics := model.JobSeniorityLevelAnalytics{
		Beginner:     int(beginner_jobs),
		Intermediate: int(intermediate_jobs),
		Senior:       int(senior_jobs),
		Unspecified:  len(jobIds) - int(beginner_jobs) - int(intermediate_jobs) - int(senior_jobs),
	}

	var one_to_three_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("id IN ?", jobIds).Where("experience < ? AND experience >= ?", "3", "1").Count(&one_to_three_jobs).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("error counting one to three years of experience jobs!")
	}

	var three_to_five_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("id IN ?", jobIds).Where("experience < ? AND experience >= ?", "5", "3").Count(&three_to_five_jobs).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("error counting three to five years of experience jobs!")
	}

	var five_to_seven_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("id IN ?", jobIds).Where("experience < ? AND experience >= ?", "7", "5").Count(&five_to_seven_jobs).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("error counting five to seven years of experience jobs!")
	}

	var seven_to_nine_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("id IN ?", jobIds).Where("experience < ? AND experience >= ?", "9", "7").Count(&seven_to_nine_jobs).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("error counting seven to nine years of experience jobs!")
	}

	var nine_and_above_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("id IN ?", jobIds).Where("experience >= ?", "9").Count(&nine_and_above_jobs).Error; err != nil {
		log.Error().Str("object", "EmployeeProfile").Msg(err.Error())
		return nil, errors.New("error counting nine and above years of experience jobs!")
	}

	job_experience_analytics := model.JobExperienceAnalytics{
		BelowOne:     len(jobIds) - int(one_to_three_jobs) - int(three_to_five_jobs) - int(five_to_seven_jobs) - int(seven_to_nine_jobs) - int(nine_and_above_jobs),
		OneToThree:   int(one_to_three_jobs),
		ThreeToFive:  int(three_to_five_jobs),
		FiveToSeven:  int(five_to_seven_jobs),
		SevenToNine:  int(seven_to_nine_jobs),
		NineAndAbove: int(nine_and_above_jobs),
	}

	analytics := &model.EmployeeAnalytics{
		JobApplicationStatus:      &applications_analytics,
		AppliedJobsEducationLevel: &job_education_level_analytics,
		AppliedJobsExperience:     &job_experience_analytics,
		AppliedJobsSeniority:      &job_seniority_level_analytics,
	}

	return analytics, nil
}

// CreateEmployee is the resolver for the createEmployee field.
func (r *mutationResolver) CreateEmployee(ctx context.Context, input model.NewEmployee) (*model.UnverifiedEmployee, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate inputs
	if err := input.Validate(); err != nil {
		return nil, err
	}

	//check if the phone number exists in the database
	phoneexists, err := phoneutils.CheckEmployeePhoneNumber(r.Sql.Db, input.PhoneNumber)

	//return any error that might be associated with checking the phone number's existence in the database
	if err != nil {
		log.Error().Str("phone_number", input.PhoneNumber).Str("path", "CreateEmployee").Msg(err.Error())
		return nil, errors.New("error checking phone number's existence")
	}

	//return an error if phone number exists in the database
	if phoneexists.Verified == true || phoneexists.Unverified == true {
		return nil, errors.New("phone number already exists")
	}

	//encrypt input password
	encryptedpassword, err := encrypt.HashPassword(input.Password)
	if err != nil {
		log.Error().Str("password", input.Password).Str("path", "CreateEmployee").Msg(err.Error())
		return nil, err
	}
	//create an unverified employee data
	unverifiedemployee := &model.UnverifiedEmployee{
		Name:           input.Name,
		PhoneNumber:    input.PhoneNumber,
		Password:       encryptedpassword,
		Profilepicture: input.Profilepicture,
	}

	/*send an OTP code to the phone number associated with the unverified employee record, return error if there is any
	if err := phoneutils.SendOtp(unverifiedemployee.PhoneNumber); err != nil {
		log.Error().Str("phone_number", input.PhoneNumber).Str("path", "CreateEmployee").Msg(err.Error())
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/

	//create an unverified employee record in the database and return if operation succeeds
	if err := r.Sql.Db.Create(unverifiedemployee).Error; err != nil {
		log.Error().Str("name", input.Name).Str("path", "CreateEmployee").Msg(err.Error())
		return nil, errors.New("an unexpected error occurred while creating the employee account. please try again later or contact support")
	}

	return unverifiedemployee, nil
}

// VerifyEmployee is the resolver for the verifyEmployee field.
func (r *mutationResolver) VerifyEmployee(ctx context.Context, input model.Verificationinfo) (*model.Employee, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate inputs
	if err := input.Validate(); err != nil {
		return nil, err
	}

	/*Check the validity of an OTP code
	if err := phoneutils.CheckOtp(input.PhoneNumber, input.Otp); err != nil {
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/
	if input.Otp != "777777" {
		return nil, errors.New("incorrect OTP code")
	}
	//declare an unverifiedemployee variable
	var unverifiedemployee *model.UnverifiedEmployee

	// Find the first unverified employee that matches the input phone number from the unverified employee table
	if err := r.Sql.Db.Where("phone_number = ?", input.PhoneNumber).First(&unverifiedemployee).Error; err != nil {
		log.Info().Str("phone_number", input.PhoneNumber).Str("path", "VerifyEmployee").Msg("phone number does not exist")
		return nil, errors.New("error finding unverified employee with phone number: " + input.PhoneNumber)
	}

	// transform the unverified employee model into employee model and copy it
	employee := &model.Employee{
		Name:           unverifiedemployee.Name,
		PhoneNumber:    unverifiedemployee.PhoneNumber,
		Password:       unverifiedemployee.Password,
		Profilepicture: unverifiedemployee.Profilepicture,
	}

	// take the newly transformed and copied employee data and transfer it into the official verified employee table
	if err := r.Sql.Db.Create(employee).Error; err != nil {
		log.Info().Str("name", employee.Name).Str("path", "VerifyEmployee").Msg(err.Error())
		return nil, errors.New("Failed to verify employee account. please try again later or contact support")
	}

	// delete the unverified employee from the unverified employee table
	if err := r.Sql.Db.Delete(unverifiedemployee).Error; err != nil {
		log.Error().Str("path", "VerifyEmployee").Int("record_id", unverifiedemployee.ID).Msg(err.Error())
		return nil, errors.New("Failed to complete employee account verification. please try again later or contact support")
	}

	log.Info().Int("initial_record_id", unverifiedemployee.ID).Int("final_record_id", employee.ID).Str("path", "VerifyEmployee").Msg("completed unverified employee to employee data transaction")
	return employee, nil
}

// EmployeeLogin is the resolver for the employeeLogin field.
func (r *mutationResolver) EmployeeLogin(ctx context.Context, input model.EmployeeLogin) (*string, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	//validate EmployeeLogin input
	if err := input.Validate(); err != nil {
		return nil, err
	}

	//declare an employee variable
	var employee *model.Employee
	// Find the first employee that matches the input phone number from the employee table

	if err := r.Sql.Db.Where("phone_number = ?", input.PhoneNumber).First(&employee).Error; err != nil {
		log.Info().Str("phone_number", input.PhoneNumber).Str("path", "EmployeeLogin").Msg(err.Error())
		return nil, errors.New("phone number does not exist")
	}
	//check if the password of the employee matches the input password
	if err := encrypt.CheckPassword(employee.Password, input.Password); err != nil {
		log.Info().Str("path", "EmployeeLogin").Msg(err.Error())
		return nil, errors.New("Invalid phone number or password")
	}

	credentials := jwt.TokenCredentials{
		Id:   strconv.Itoa(employee.ID),
		Role: "employee",
	}
	token, err := jwt.GenerateToken(credentials)
	if err != nil {
		log.Error().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "EmployeeLogin").Msg(err.Error())
		return nil, errors.New("error generating accessToken")
	}
	log.Info().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "EmployeeLogin").Msg("employee logged in successfully!")
	return &token, nil
}

// ForgotEmployeePassword is the resolver for the forgotEmployeePassword field.
func (r *mutationResolver) ForgotEmployeePassword(ctx context.Context, phoneNumber string) (*model.SendCodeStatus, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	//validate phone number
	if err := validate.ValidateKenyanPhoneNumber(phoneNumber); err != nil {
		return nil, err
	}

	//check if the phone number exists in the database
	phoneexists, err := phoneutils.CheckEmployeePhoneNumber(r.Sql.Db, phoneNumber)

	//return any error that might be associated with checking the phone number's existence in the database
	if err != nil {
		log.Error().Str("phone_number", phoneNumber).Str("path", "ForgotEmployeePassword").Msg(err.Error())
		return nil, err
	}
	//return an error if phone number exists in the unverified employee table
	if phoneexists.Verified != true && phoneexists.Unverified == true {
		return nil, errors.New("phone number has been registered but is yet to be verified")
	}
	//return an error if phone number is neither registered nor verified
	if phoneexists.Verified != true && phoneexists.Unverified != true {
		return nil, errors.New("phone number does not exist")
	}
	/*send an OTP code to the phone number provided, return error if there is any
	if err := phoneutils.SendOtp(phoneNumber); err != nil {
		log.Error().Str("phone_number", phoneNumber).Str("path", "ForgotEmployeePassword").Msg(err.Error())
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/
	//return status on success
	sendcodestatus := &model.SendCodeStatus{
		PhoneNumber: phoneNumber,
		Success:     true,
	}
	return sendcodestatus, nil
}

// RequestEmployeePasswordReset is the resolver for the requestEmployeePasswordReset field.
func (r *mutationResolver) RequestEmployeePasswordReset(ctx context.Context, input *model.Verificationinfo) (*string, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate inputs
	if err := input.Validate(); err != nil {
		return nil, err
	}

	/*Check the validity of an OTP code
	if err := phoneutils.CheckOtp(input.PhoneNumber, input.Otp); err != nil {
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/
	if input.Otp != "777777" {
		return nil, errors.New("incorrect OTP code")
	}

	//declare an employee variable
	var employee *model.Employee

	// Find the first employee that matches the input phone number from the employee table

	if err := r.Sql.Db.Where("phone_number = ?", input.PhoneNumber).First(&employee).Error; err != nil {
		log.Info().Str("phone_number", input.PhoneNumber).Str("path", "RequestEmployeePasswordReset").Msg(err.Error())
		return nil, errors.New("phone number does not exist")
	}

	credentials := jwt.TokenCredentials{
		Id:   strconv.Itoa(employee.ID),
		Role: "employee",
	}
	token, err := jwt.GenerateToken(credentials)
	if err != nil {
		log.Error().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "RequestEmployeePasswordReset").Msg(err.Error())
		return nil, errors.New("error generating accessToken")
	}
	return &token, nil
}

// ResetEmployeePassword is the resolver for the resetEmployeePassword field.
func (r *mutationResolver) ResetEmployeePassword(ctx context.Context, newPassword string) (*model.Employee, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	user, err := auth.ForContext(ctx)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, errors.New("access to reset employee password denied!")
	}
	role := user.GetRole()
	if role != "employee" {
		return nil, errors.New("access to reset employee password denied. Only available for registered and logged in employees. To fix check access token!")
	}
	id, err := user.GetID()

	if err != nil {
		errors.New("could not access employee's id!")
	}

	//validate inputs
	if err := validate.ValidatePassword(newPassword); err != nil {
		return nil, err
	}

	var employee *model.Employee
	//fetch the record to be updated from the database
	if err := r.Sql.Db.First(&employee, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "ResetEmployeePassword").Msg(err.Error())
		return nil, err
	}
	//encrypt input password
	encryptedpassword, err := encrypt.HashPassword(newPassword)
	if err != nil {
		log.Error().Str("password", newPassword).Str("path", "ResetEmployeePassword").Msg(err.Error())
		return nil, err
	}
	// Update the records' attributes with `map`
	if err := r.Sql.Db.Model(&employee).Updates(map[string]interface{}{"password": encryptedpassword}).Error; err != nil {
		log.Error().Int("id", employee.ID).Str("path", "ResetEmployeePassword").Msg(fmt.Sprintf("updating employee password failed: %s", err.Error()))
		return nil, err
	}

	//fetch the record again from the database, this time the updated version
	if err := r.Sql.Db.First(&employee, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "ResetEmployeePassword").Msg(err.Error())
		return nil, err
	}

	//return the updated record
	return employee, nil
}

// EditEmployeeProfile is the resolver for the editEmployeeProfile field.
func (r *mutationResolver) EditEmployeeProfile(ctx context.Context, input model.UpdateEmployee) (*model.EmployeeProfile, error) {
	user, err := auth.ForContext(ctx)

	if err != nil {
		return nil, err
	}

	id, err := user.GetID()

	if err != nil {
		errors.New("could not access employee's id!")
	}

	//declare an employee variable
	var employee *model.Employee

	//Find the first employee that matches the input id
	if err := r.Sql.Db.Where("id = ?", id).First(&employee).Error; err != nil {
		log.Info().Int("id", id).Str("path", "EditEmployeeProfile").Msg("id does not exist")
		return nil, errors.New("error finding employee with id: " + strconv.Itoa(id))
	}

	employee.Name = input.Name
	employee.PhoneNumber = input.PhoneNumber
	employee.Profilepicture = input.Profilepicture

	// Update employee record
	if err := r.Sql.Db.Save(&employee).Error; err != nil {
		log.Info().Int("id", id).Str("path", "EditEmployeeProfile").Msg("failed to update employee")
		return nil, errors.New("error updating employee with id: " + strconv.Itoa(id))
	}

	employeeprofile := &model.EmployeeProfile{
		ID:             employee.ID,
		CreatedAt:      employee.CreatedAt,
		UpdatedAt:      employee.UpdatedAt,
		Name:           employee.Name,
		PhoneNumber:    employee.PhoneNumber,
		Profilepicture: employee.Profilepicture,
	}

	return employeeprofile, nil
}

// EmployeePhoneNumberExists is the resolver for the employeePhoneNumberExists field.
func (r *queryResolver) EmployeePhoneNumberExists(ctx context.Context, phoneNumber string) (*model.PhoneNumberExists, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	phoneexists, err := phoneutils.CheckEmployeePhoneNumber(r.Sql.Db, phoneNumber)

	if err != nil {
		log.Error().Str("phone_number", phoneNumber).Str("path", "EmployeePhoneNumberExists").Msg(err.Error())
		return nil, err
	}

	return phoneexists, nil
}

// GetEmployeeProfile is the resolver for the getEmployeeProfile field.
func (r *queryResolver) GetEmployeeProfile(ctx context.Context) (*model.EmployeeProfile, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	user, err := auth.ForContext(ctx)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, errors.New("access to get employee profile denied!")
	}
	role := user.GetRole()
	if role != "employee" {
		return nil, errors.New("access to get employee profile denied. Only available for registered and logged in employees. To fix check access token!")
	}
	id, err := user.GetID()

	if err != nil {
		errors.New("could not access employee's id!")
	}

	var employee *model.Employee

	if err := r.Sql.Db.First(&employee, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "GetEmployeeProfile").Msg(err.Error())
		return nil, errors.New("could not access employee's profile!")
	}

	log.Info().Int("id", id).Str("role", role).Str("path", "GetEmployeeProfile").Msg("getting employee's profile")

	employeeprofile := &model.EmployeeProfile{
		ID:             employee.ID,
		CreatedAt:      employee.CreatedAt,
		UpdatedAt:      employee.UpdatedAt,
		Name:           employee.Name,
		PhoneNumber:    employee.PhoneNumber,
		Profilepicture: employee.Profilepicture,
	}
	return employeeprofile, nil
}

// GetEmployeesProfile is the resolver for the getEmployeesProfile field.
func (r *queryResolver) GetEmployeesProfile(ctx context.Context) ([]*model.EmployeeProfile, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	var employees []*model.Employee
	if err := r.Sql.Db.Find(&employees).Error; err != nil {
		log.Error().Str("path", "GetEmployeesProfile").Msg(err.Error())
		return nil, errors.New("could not access employees' profile!")
	}
	log.Info().Str("path", "GetEmployeesProfile").Msg("getting employees' profile")

	var employeesprofile []*model.EmployeeProfile

	for _, employee := range employees {
		employeeprofile := &model.EmployeeProfile{
			ID:             employee.ID,
			CreatedAt:      employee.CreatedAt,
			UpdatedAt:      employee.UpdatedAt,
			Name:           employee.Name,
			PhoneNumber:    employee.PhoneNumber,
			Profilepicture: employee.Profilepicture,
		}
		employeesprofile = append(employeesprofile, employeeprofile)
	}

	return employeesprofile, nil
}

// EmployeeProfile returns EmployeeProfileResolver implementation.
func (r *Resolver) EmployeeProfile() EmployeeProfileResolver { return &employeeProfileResolver{r} }

type employeeProfileResolver struct{ *Resolver }
