package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"errors"
	"fmt"
	"strconv"

	"github.com/GigaDesk/eardrum-graph/neo4jschool"
	"github.com/GigaDesk/eardrum-graph/neo4jstudent"
	"github.com/GigaDesk/eardrum-prefix/prefix"
	"github.com/GigaDesk/eardrum-server/auth"
	"github.com/GigaDesk/eardrum-server/encrypt"
	"github.com/GigaDesk/eardrum-server/graph/model"
	"github.com/GigaDesk/eardrum-server/phoneutils"
	"github.com/GigaDesk/eardrum-server/pkg/jwt"
	"github.com/GigaDesk/eardrum-server/shutdown"
	"github.com/GigaDesk/eardrum-server/wrappers"
	"github.com/rs/zerolog/log"
)

// AddStudents is the resolver for the AddStudents field.
func (r *mutationResolver) AddStudents(ctx context.Context, students []*model.NewStudent) ([]*model.Student, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, errors.New("access to add students denied!")
	}
	role := user.GetRole()
	if role != "school" {
		return nil, errors.New("access to add students denied. Only available for registered and logged in schools. To fix check access token!")
	}

	id, err := user.GetID()

	if err != nil {
		errors.New("could not access school's id!")
	}

	log.Info().Str("role", role).Int("id", id).Str("path", "AddStudents").Msg("adding students")

	//a slice of students
	var s []*model.Student
	// a map of registration numbers to a boolean that shows if they already exist or not
	m := make(map[string]bool)
	//a slice of non repeated registration numbers
	var registration_numbers []string
	for _, student := range students {
		n := &model.Student{
			RegistrationNumber: prefix.PrefixWithId(student.RegistrationNumber, id),
			Name:               student.Name,
			PhoneNumber:        student.PhoneNumber,
			DateOfAdmission:    student.DateOfAdmission,
			DateOfBirth:        student.DateOfBirth,
			ProfilePicture:     student.ProfilePicture,
		}

		if m[n.RegistrationNumber] {
			log.Info().Str("registration_number", n.RegistrationNumber).Str("path", "AddStudents").Msg("student contain duplicate registration number")
			return nil, errors.New(fmt.Sprintf("student registration numbers %s is duplicated", n.RegistrationNumber))
		}
		m[n.RegistrationNumber] = true

		registration_numbers = append(registration_numbers, n.RegistrationNumber)

		//encrypt student password
		encryptedpassword, err := encrypt.HashPassword(student.Password)
		if err != nil {
			return nil, err
		}
		n.Password = encryptedpassword
		s = append(s, n)
	}
	//get students in the database with similar registration numbers
	var duplicated_students []model.Student
	r.Sql.Db.Where("registration_number IN ?", registration_numbers).Find(&duplicated_students)

	//check if there exists students in the database with similar registration numbers
	if len(duplicated_students) != 0 {
		log.Info().Str("registration_number", duplicated_students[0].RegistrationNumber).Str("path", "AddStudents").Msg("student with registration number already exists")
		return nil, errors.New(fmt.Sprintf("student with registration number %s already exists", duplicated_students[0].RegistrationNumber))
	}
	//Create records in postgres
	if err := r.Sql.Db.Create(s).Error; err != nil {
		log.Error().Str("first_record_name", s[0].Name).Str("path", "AddStudents").Msg(err.Error())
		return nil, errors.New("an unexpected error occurred while creating the school account. please try again later or contact support")
	}
	//Create records in neo4j
	result, err := neo4jschool.CheckSchool(r.Neo4j, id)
	if err != nil {
		go shutdown.InitiateShutdown(err, "AddStudents", id)
		return nil, errors.New("a serious error occurred while adding students. please try again later or contact support")
	}
	if result == false {
		go shutdown.InitiateShutdown(errors.New("school does not exist"), "AddStudents", id)
		return nil, errors.New("a serious synchronization error occurred while adding students. please try again later or contact support")
	}
	for _, student := range s {
		n := wrappers.Neo4jStudentWrapper{
			Student: student,
		}

		if err := neo4jstudent.CreateStudent(r.Neo4j, n, id); err != nil {
			go shutdown.InitiateShutdown(err, "AddStudents", n.ID)
			return nil, errors.New("a serious synchronization error occurred while adding: " + student.Name)
		}
		student.RegistrationNumber = prefix.DePrefixWithId(student.RegistrationNumber, id)
	}
	return s, nil
}

// StudentLogin is the resolver for the studentLogin field.
func (r *mutationResolver) StudentLogin(ctx context.Context, input model.StudentLogin) (*string, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//declare a student variable
	var student *model.Student

	// Find the first school that matches the input registration number from the student table

	if err := r.Sql.Db.Where("registration_number = ?", prefix.PrefixWithId(input.RegistrationNumber, input.Schoolid)).First(&student).Error; err != nil {
		log.Info().Str("registration_number", input.RegistrationNumber).Str("path", "StudentLogin").Msg(err.Error())
		return nil, errors.New("registration number does not exist")
	}
	//check if the password of the student matches the input password
	if err := encrypt.CheckPassword(student.Password, input.Password); err != nil {
		log.Info().Str("path", "StudentLogin").Msg(err.Error())
		return nil, errors.New("Invalid registration number or password")
	}

	credentials := jwt.TokenCredentials{
		Id:   strconv.Itoa(student.ID),
		Role: "student",
	}
	token, err := jwt.GenerateToken(credentials)
	if err != nil {
		log.Error().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "StudentLogin").Msg(err.Error())
		return nil, errors.New("error generating accessToken")
	}
	log.Info().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "StudentLogin").Msg("student logged in successfully!")
	return &token, nil
}

// ForgotStudentPassword is the resolver for the forgotStudentPassword field.
func (r *mutationResolver) ForgotStudentPassword(ctx context.Context, phoneNumber string) (*model.SendCodeStatus, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//declare a student variable
	var student *model.Student
	//check if the phone number exists in the database in the student table
	if err := r.Sql.Db.Where("phone_number = ?", phoneNumber).First(&student).Error; err != nil {
		log.Info().Str("phone_number", phoneNumber).Str("path", "ForgotStudentPassword").Msg(err.Error())
		return nil, errors.New("phone number does not exist")
	}

	//send an OTP code to the phone number provided, return error if there is any
	if err := phoneutils.SendOtp(phoneNumber); err != nil {
		log.Error().Str("phone_number", phoneNumber).Str("path", "ForgotStudentPassword").Msg(err.Error())
		return nil, err
	}
	//return status on success
	sendcodestatus := &model.SendCodeStatus{
		PhoneNumber: phoneNumber,
		Success:     true,
	}
	return sendcodestatus, nil
}

// RequestStudentPasswordReset is the resolver for the requestStudentPasswordReset field.
func (r *mutationResolver) RequestStudentPasswordReset(ctx context.Context, input *model.Verificationinfo) (*string, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//Check the validity of an OTP code
	if err := phoneutils.CheckOtp(input.PhoneNumber, input.Otp); err != nil {
		return nil, err
	}
	//declare a student variable
	var student *model.Student

	// Find the first school that matches the input phone number from the school table

	if err := r.Sql.Db.Where("phone_number = ?", input.PhoneNumber).First(&student).Error; err != nil {
		log.Info().Str("phone_number", input.PhoneNumber).Str("path", "RequestStudentPasswordReset").Msg(err.Error())
		return nil, errors.New("phone number does not exist")
	}

	credentials := jwt.TokenCredentials{
		Id:   strconv.Itoa(student.ID),
		Role: "student",
	}
	token, err := jwt.GenerateToken(credentials)
	if err != nil {
		log.Error().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "RequestStudentPasswordReset").Msg(err.Error())
		return nil, errors.New("error generating accessToken")
	}
	return &token, nil
}

// ResetStudentPassword is the resolver for the resetStudentPassword field.
func (r *mutationResolver) ResetStudentPassword(ctx context.Context, newPassword string) (*model.Student, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, errors.New("access to ResetStudentPassword denied!")
	}
	role := user.GetRole()
	if role != "student" {
		return nil, errors.New("access to ResetStudentPassword denied. Only available for registered and logged in students. To fix check access token!")
	}
	id, err := user.GetID()

	if err != nil {
		errors.New("could not access student's id!")
	}

	var student *model.Student
	//fetch the record to be updated from the database
	if err := r.Sql.Db.First(&student, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "ResetStudentPassword").Msg(err.Error())
		return nil, err
	}
	//encrypt input password
	encryptedpassword, err := encrypt.HashPassword(newPassword)
	if err != nil {
		log.Error().Str("password", newPassword).Str("path", "ResetStudentPassword").Msg(err.Error())
		return nil, err
	}
	// Update the records' attributes with `map`
	if err := r.Sql.Db.Model(&student).Updates(map[string]interface{}{"password": encryptedpassword}).Error; err != nil {
		log.Error().Int("id", student.ID).Str("path", "ResetStudentPassword").Msg(fmt.Sprintf("updating student password failed: %s", err.Error()))
		return nil, err
	}

	//fetch the record again from the database, this time the updated version
	if err := r.Sql.Db.First(&student, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "ResetStudentPassword").Msg(err.Error())
		return nil, err
	}
	student.RegistrationNumber = prefix.DePrefixWithoutId(student.RegistrationNumber)
	//return the updated record
	return student, nil
}

// GetStudentProfile is the resolver for the getStudentProfile field.
func (r *queryResolver) GetStudentProfile(ctx context.Context) (*model.StudentProfile, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, errors.New("access to student profile denied!")
	}
	role := user.GetRole()
	if role != "student" {
		return nil, errors.New("access to student profile denied. Only available for registered and logged in students. To fix check access token!")
	}
	id, err := user.GetID()

	if err != nil {
		errors.New("could not access student's id!")
	}

	var student *model.Student
	if err := r.Sql.Db.First(&student, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "GetStudentProfile").Msg(err.Error())
		return nil, errors.New("could not access student's profile!")
	}
	studentprofile := &model.StudentProfile{
		ID:                 student.ID,
		CreatedAt:          student.CreatedAt,
		UpdatedAt:          student.UpdatedAt,
		DeletedAt:          student.DeletedAt,
		RegistrationNumber: student.RegistrationNumber,
		Name:               student.Name,
		PhoneNumber:        student.PhoneNumber,
		Password:           student.Password,
		DateOfAdmission:    student.DateOfAdmission,
		ProfilePicture:     student.ProfilePicture,
	}
	studentprofile.RegistrationNumber = prefix.DePrefixWithoutId(studentprofile.RegistrationNumber)
	log.Info().Int("id", id).Str("role", role).Str("path", "GetStudentProfile").Msg("getting student profile")
	return studentprofile, nil
}

// School is the resolver for the school field.
func (r *studentProfileResolver) School(ctx context.Context, obj *model.StudentProfile) (*model.SchoolProfile, error) {
	user := auth.ForContext(ctx)
	id,_:=user.GetID()
	var school *model.School
	if err := r.Sql.Db.First(&school, 12).Error; err != nil {
		log.Error().Int("id", id).Str("role", user.GetRole()).Msg(err.Error())
		return nil, errors.New("could not access schools profile!")
	}
	log.Info().Int("id", id).Str("role", user.GetRole()).Msg("getting school profile")
	schoolprofile := &model.SchoolProfile{
		ID:          school.ID,
		CreatedAt:   school.CreatedAt,
		UpdatedAt:   school.UpdatedAt,
		Name:        school.Name,
		PhoneNumber: school.PhoneNumber,
		Badge:       school.Badge,
		Website:     school.Website,
	}
	return schoolprofile, nil
}

// StudentProfile returns StudentProfileResolver implementation.
func (r *Resolver) StudentProfile() StudentProfileResolver { return &studentProfileResolver{r} }

type studentProfileResolver struct{ *Resolver }
