// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"time"

	"github.com/mitchellh/mapstructure"
)

// GetInputStruct returns struct filled from map obj defined by name
// Example useage struct validation with github.com/go-playground/validator by directive:
//
//	func ValidateDirective(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error) {
//	  field := graphql.GetPathContext(ctx)
//	  if data, ok := obj.(map[string]interface{}); ok {
//	    for _, v := range field.ParentField.Field.Arguments {
//	      name := v.Value.ExpectedType.Name()
//	      model, err := model.GetInputStruct(name, data)
//	      if err != nil {
//	        //handle not found error
//	      }
//	      if err := validate.Struct(model); err != nil {
//	      //handle error
//	      }
//	    }
//	  }
//	  return next(ctx)
//	}
func GetInputStruct(name string, obj map[string]interface{}) (interface{}, error) {
	switch name {
	case "SchoolInput":
		return SchoolInputFromMap(obj)
	case "StudentInput":
		return StudentInputFromMap(obj)
	case "UnverifiedSchoolInput":
		return UnverifiedSchoolInputFromMap(obj)
	}
	return nil, fmt.Errorf("%s not found", name)
}

// SchoolInputFromMap return a SchoolInput from data map
// use github.com/mitchellh/mapstructure with reflaction
func SchoolInputFromMap(data map[string]interface{}) (SchoolInput, error) {
	model := SchoolInput{}
	err := mapstructure.Decode(data, &model)
	return model, err
}

// MergeToType returns a map with all values set to SchoolPatch
func (d *SchoolPatch) MergeToType() map[string]interface{} {
	res := make(map[string]interface{})
	if d.Name != nil {
		res["name"] = *d.Name
	}
	if d.PhoneNumber != nil {
		res["phone_number"] = *d.PhoneNumber
	}
	if d.Password != nil {
		res["password"] = *d.Password
	}
	if d.Badge != nil {
		res["badge"] = d.Badge
	}
	if d.Website != nil {
		res["website"] = d.Website
	}
	return res
}

// MergeToType retuns a School filled from SchoolInput
func (d *SchoolInput) MergeToType() School {

	tmpName := d.Name

	tmpPhoneNumber := d.PhoneNumber

	tmpPassword := d.Password

	var tmpBadge *string
	if d.Badge != nil {
		tmpBadge = d.Badge
	}

	var tmpWebsite *string
	if d.Website != nil {
		tmpWebsite = d.Website
	}
	return School{
		Name:        tmpName,
		PhoneNumber: tmpPhoneNumber,
		Password:    tmpPassword,
		Badge:       tmpBadge,
		Website:     tmpWebsite,
	}
}

// StudentInputFromMap return a StudentInput from data map
// use github.com/mitchellh/mapstructure with reflaction
func StudentInputFromMap(data map[string]interface{}) (StudentInput, error) {
	model := StudentInput{}
	err := mapstructure.Decode(data, &model)
	return model, err
}

// MergeToType returns a map with all values set to StudentPatch
func (d *StudentPatch) MergeToType() map[string]interface{} {
	res := make(map[string]interface{})
	if d.RegistrationNumber != nil {
		res["registration_number"] = *d.RegistrationNumber
	}
	if d.Name != nil {
		res["name"] = *d.Name
	}
	if d.PhoneNumber != nil {
		res["phone_number"] = *d.PhoneNumber
	}
	if d.Password != nil {
		res["password"] = *d.Password
	}
	if d.DateOfAdmission != nil {
		res["date_of_admission"] = d.DateOfAdmission
	}
	if d.DateOfBirth != nil {
		res["date_of_birth"] = d.DateOfBirth
	}
	if d.ProfilePicture != nil {
		res["profile_picture"] = d.ProfilePicture
	}
	return res
}

// MergeToType retuns a Student filled from StudentInput
func (d *StudentInput) MergeToType() Student {

	tmpRegistrationNumber := d.RegistrationNumber

	tmpName := d.Name

	tmpPhoneNumber := d.PhoneNumber

	tmpPassword := d.Password

	var tmpDateOfAdmission *time.Time
	if d.DateOfAdmission != nil {
		tmpDateOfAdmission = d.DateOfAdmission
	}

	var tmpDateOfBirth *time.Time
	if d.DateOfBirth != nil {
		tmpDateOfBirth = d.DateOfBirth
	}

	var tmpProfilePicture *string
	if d.ProfilePicture != nil {
		tmpProfilePicture = d.ProfilePicture
	}
	return Student{
		RegistrationNumber: tmpRegistrationNumber,
		Name:               tmpName,
		PhoneNumber:        tmpPhoneNumber,
		Password:           tmpPassword,
		DateOfAdmission:    tmpDateOfAdmission,
		DateOfBirth:        tmpDateOfBirth,
		ProfilePicture:     tmpProfilePicture,
	}
}

// UnverifiedSchoolInputFromMap return a UnverifiedSchoolInput from data map
// use github.com/mitchellh/mapstructure with reflaction
func UnverifiedSchoolInputFromMap(data map[string]interface{}) (UnverifiedSchoolInput, error) {
	model := UnverifiedSchoolInput{}
	err := mapstructure.Decode(data, &model)
	return model, err
}

// MergeToType returns a map with all values set to UnverifiedSchoolPatch
func (d *UnverifiedSchoolPatch) MergeToType() map[string]interface{} {
	res := make(map[string]interface{})
	if d.Name != nil {
		res["name"] = *d.Name
	}
	if d.PhoneNumber != nil {
		res["phone_number"] = *d.PhoneNumber
	}
	if d.Password != nil {
		res["password"] = *d.Password
	}
	if d.Badge != nil {
		res["badge"] = d.Badge
	}
	if d.Website != nil {
		res["website"] = d.Website
	}
	return res
}

// MergeToType retuns a UnverifiedSchool filled from UnverifiedSchoolInput
func (d *UnverifiedSchoolInput) MergeToType() UnverifiedSchool {

	tmpName := d.Name

	tmpPhoneNumber := d.PhoneNumber

	tmpPassword := d.Password

	var tmpBadge *string
	if d.Badge != nil {
		tmpBadge = d.Badge
	}

	var tmpWebsite *string
	if d.Website != nil {
		tmpWebsite = d.Website
	}
	return UnverifiedSchool{
		Name:        tmpName,
		PhoneNumber: tmpPhoneNumber,
		Password:    tmpPassword,
		Badge:       tmpBadge,
		Website:     tmpWebsite,
	}
}
