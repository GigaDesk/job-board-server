// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/fasibio/autogql/runtimehelper"
)

// AddAdmin result with filterable data and affected rows
type AddAdminPayload struct {
	Admin    *AdminQueryResult `json:"admin"`
	Affected []*Admin          `json:"affected"`
}

// AddEmployee result with filterable data and affected rows
type AddEmployeePayload struct {
	Employee *EmployeeQueryResult `json:"employee"`
	Affected []*Employee          `json:"affected"`
}

// AddEmployer result with filterable data and affected rows
type AddEmployerPayload struct {
	Employer *EmployerQueryResult `json:"employer"`
	Affected []*Employer          `json:"affected"`
}

// AddJob result with filterable data and affected rows
type AddJobPayload struct {
	Job      *JobQueryResult `json:"job"`
	Affected []*Job          `json:"affected"`
}

// AddUnapprovedJob result with filterable data and affected rows
type AddUnapprovedJobPayload struct {
	UnapprovedJob *UnapprovedJobQueryResult `json:"unapprovedJob"`
	Affected      []*UnapprovedJob          `json:"affected"`
}

// AddUnverifiedAdmin result with filterable data and affected rows
type AddUnverifiedAdminPayload struct {
	UnverifiedAdmin *UnverifiedAdminQueryResult `json:"unverifiedAdmin"`
	Affected        []*UnverifiedAdmin          `json:"affected"`
}

// AddUnverifiedEmployee result with filterable data and affected rows
type AddUnverifiedEmployeePayload struct {
	UnverifiedEmployee *UnverifiedEmployeeQueryResult `json:"unverifiedEmployee"`
	Affected           []*UnverifiedEmployee          `json:"affected"`
}

// AddUnverifiedEmployer result with filterable data and affected rows
type AddUnverifiedEmployerPayload struct {
	UnverifiedEmployer *UnverifiedEmployerQueryResult `json:"unverifiedEmployer"`
	Affected           []*UnverifiedEmployer          `json:"affected"`
}

type Admin struct {
	ID          int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt   time.Time                 `json:"createdAt"`
	UpdatedAt   time.Time                 `json:"updatedAt"`
	DeletedAt   *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Name        string                    `json:"name"`
	PhoneNumber string                    `json:"phone_number"`
	Password    string                    `json:"password"`
}

// Filter input selection for Admin
// Can be used f.e.: by queryAdmin
type AdminFiltersInput struct {
	ID          *IntFilterInput      `json:"id,omitempty"`
	CreatedAt   *TimeFilterInput     `json:"createdAt,omitempty"`
	UpdatedAt   *TimeFilterInput     `json:"updatedAt,omitempty"`
	Name        *StringFilterInput   `json:"name,omitempty"`
	PhoneNumber *StringFilterInput   `json:"phone_number,omitempty"`
	Password    *StringFilterInput   `json:"password,omitempty"`
	And         []*AdminFiltersInput `json:"and,omitempty"`
	Or          []*AdminFiltersInput `json:"or,omitempty"`
	Not         *AdminFiltersInput   `json:"not,omitempty"`
}

// Admin Input value to add new Admin
type AdminInput struct {
	Name        string `json:"name"`
	PhoneNumber string `json:"phone_number"`
	Password    string `json:"password"`
}

type AdminLogin struct {
	PhoneNumber string `json:"phone_number"`
	Password    string `json:"password"`
}

// Order Admin by asc or desc
type AdminOrder struct {
	Asc  *AdminOrderable `json:"asc,omitempty"`
	Desc *AdminOrderable `json:"desc,omitempty"`
}

// Admin Patch value all values are optional to update Admin entities
type AdminPatch struct {
	Name        *string `json:"name,omitempty"`
	PhoneNumber *string `json:"phone_number,omitempty"`
	Password    *string `json:"password,omitempty"`
}

type AdminProfile struct {
	ID          int       `json:"id"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
	Name        string    `json:"name"`
	PhoneNumber string    `json:"phone_number"`
}

// Admin result
type AdminQueryResult struct {
	Data       []*Admin `json:"data"`
	Count      int      `json:"count"`
	TotalCount int      `json:"totalCount"`
}

// Boolean Filter simple datatypes
type BooleanFilterInput struct {
	And     []*bool             `json:"and,omitempty"`
	Or      []*bool             `json:"or,omitempty"`
	Not     *BooleanFilterInput `json:"not,omitempty"`
	Is      *bool               `json:"is,omitempty"`
	Null    *bool               `json:"null,omitempty"`
	NotNull *bool               `json:"notNull,omitempty"`
}

// DeleteAdmin result with filterable data and count of affected entries
type DeleteAdminPayload struct {
	Admin *AdminQueryResult `json:"admin"`
	// Count of deleted Admin entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteEmployee result with filterable data and count of affected entries
type DeleteEmployeePayload struct {
	Employee *EmployeeQueryResult `json:"employee"`
	// Count of deleted Employee entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteEmployer result with filterable data and count of affected entries
type DeleteEmployerPayload struct {
	Employer *EmployerQueryResult `json:"employer"`
	// Count of deleted Employer entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteJob result with filterable data and count of affected entries
type DeleteJobPayload struct {
	Job *JobQueryResult `json:"job"`
	// Count of deleted Job entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteUnapprovedJob result with filterable data and count of affected entries
type DeleteUnapprovedJobPayload struct {
	UnapprovedJob *UnapprovedJobQueryResult `json:"unapprovedJob"`
	// Count of deleted UnapprovedJob entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteUnverifiedAdmin result with filterable data and count of affected entries
type DeleteUnverifiedAdminPayload struct {
	UnverifiedAdmin *UnverifiedAdminQueryResult `json:"unverifiedAdmin"`
	// Count of deleted UnverifiedAdmin entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteUnverifiedEmployee result with filterable data and count of affected entries
type DeleteUnverifiedEmployeePayload struct {
	UnverifiedEmployee *UnverifiedEmployeeQueryResult `json:"unverifiedEmployee"`
	// Count of deleted UnverifiedEmployee entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteUnverifiedEmployer result with filterable data and count of affected entries
type DeleteUnverifiedEmployerPayload struct {
	UnverifiedEmployer *UnverifiedEmployerQueryResult `json:"unverifiedEmployer"`
	// Count of deleted UnverifiedEmployer entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

type Dummy struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

type Employee struct {
	ID             int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt      time.Time                 `json:"createdAt"`
	UpdatedAt      time.Time                 `json:"updatedAt"`
	DeletedAt      *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Name           string                    `json:"name"`
	PhoneNumber    string                    `json:"phone_number"`
	Password       string                    `json:"password"`
	Profilepicture *string                   `json:"profilepicture,omitempty"`
}

// Filter input selection for Employee
// Can be used f.e.: by queryEmployee
type EmployeeFiltersInput struct {
	ID             *IntFilterInput         `json:"id,omitempty"`
	CreatedAt      *TimeFilterInput        `json:"createdAt,omitempty"`
	UpdatedAt      *TimeFilterInput        `json:"updatedAt,omitempty"`
	Name           *StringFilterInput      `json:"name,omitempty"`
	PhoneNumber    *StringFilterInput      `json:"phone_number,omitempty"`
	Password       *StringFilterInput      `json:"password,omitempty"`
	Profilepicture *StringFilterInput      `json:"profilepicture,omitempty"`
	And            []*EmployeeFiltersInput `json:"and,omitempty"`
	Or             []*EmployeeFiltersInput `json:"or,omitempty"`
	Not            *EmployeeFiltersInput   `json:"not,omitempty"`
}

// Employee Input value to add new Employee
type EmployeeInput struct {
	Name           string  `json:"name"`
	PhoneNumber    string  `json:"phone_number"`
	Password       string  `json:"password"`
	Profilepicture *string `json:"profilepicture,omitempty"`
}

type EmployeeLogin struct {
	PhoneNumber string `json:"phone_number"`
	Password    string `json:"password"`
}

// Order Employee by asc or desc
type EmployeeOrder struct {
	Asc  *EmployeeOrderable `json:"asc,omitempty"`
	Desc *EmployeeOrderable `json:"desc,omitempty"`
}

// Employee Patch value all values are optional to update Employee entities
type EmployeePatch struct {
	Name           *string `json:"name,omitempty"`
	PhoneNumber    *string `json:"phone_number,omitempty"`
	Password       *string `json:"password,omitempty"`
	Profilepicture *string `json:"profilepicture,omitempty"`
}

type EmployeeProfile struct {
	ID             int       `json:"id"`
	CreatedAt      time.Time `json:"createdAt"`
	UpdatedAt      time.Time `json:"updatedAt"`
	Name           string    `json:"name"`
	PhoneNumber    string    `json:"phone_number"`
	Profilepicture *string   `json:"profilepicture,omitempty"`
}

// Employee result
type EmployeeQueryResult struct {
	Data       []*Employee `json:"data"`
	Count      int         `json:"count"`
	TotalCount int         `json:"totalCount"`
}

type Employer struct {
	ID          int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt   time.Time                 `json:"createdAt"`
	UpdatedAt   time.Time                 `json:"updatedAt"`
	DeletedAt   *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Name        string                    `json:"name"`
	PhoneNumber string                    `json:"phone_number"`
	Password    string                    `json:"password"`
	Badge       *string                   `json:"badge,omitempty"`
	Website     *string                   `json:"Website,omitempty"`
}

// Filter input selection for Employer
// Can be used f.e.: by queryEmployer
type EmployerFiltersInput struct {
	ID          *IntFilterInput         `json:"id,omitempty"`
	CreatedAt   *TimeFilterInput        `json:"createdAt,omitempty"`
	UpdatedAt   *TimeFilterInput        `json:"updatedAt,omitempty"`
	Name        *StringFilterInput      `json:"name,omitempty"`
	PhoneNumber *StringFilterInput      `json:"phone_number,omitempty"`
	Password    *StringFilterInput      `json:"password,omitempty"`
	Badge       *StringFilterInput      `json:"badge,omitempty"`
	Website     *StringFilterInput      `json:"Website,omitempty"`
	And         []*EmployerFiltersInput `json:"and,omitempty"`
	Or          []*EmployerFiltersInput `json:"or,omitempty"`
	Not         *EmployerFiltersInput   `json:"not,omitempty"`
}

// Employer Input value to add new Employer
type EmployerInput struct {
	Name        string  `json:"name"`
	PhoneNumber string  `json:"phone_number"`
	Password    string  `json:"password"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

type EmployerLogin struct {
	PhoneNumber string `json:"phone_number"`
	Password    string `json:"password"`
}

// Order Employer by asc or desc
type EmployerOrder struct {
	Asc  *EmployerOrderable `json:"asc,omitempty"`
	Desc *EmployerOrderable `json:"desc,omitempty"`
}

// Employer Patch value all values are optional to update Employer entities
type EmployerPatch struct {
	Name        *string `json:"name,omitempty"`
	PhoneNumber *string `json:"phone_number,omitempty"`
	Password    *string `json:"password,omitempty"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

type EmployerProfile struct {
	ID          int           `json:"id"`
	CreatedAt   time.Time     `json:"createdAt"`
	UpdatedAt   time.Time     `json:"updatedAt"`
	Name        string        `json:"name"`
	PhoneNumber string        `json:"phone_number"`
	Badge       *string       `json:"badge,omitempty"`
	Website     *string       `json:"Website,omitempty"`
	Jobs        []*JobProfile `json:"jobs,omitempty"`
}

// Employer result
type EmployerQueryResult struct {
	Data       []*Employer `json:"data"`
	Count      int         `json:"count"`
	TotalCount int         `json:"totalCount"`
}

// Filter between start and end (start > value < end)
type FloatFilterBetween struct {
	Start float64 `json:"start"`
	End   float64 `json:"end"`
}

// Float Filter simple datatypes
type FloatFilterInput struct {
	And     []*float64          `json:"and,omitempty"`
	Or      []*float64          `json:"or,omitempty"`
	Not     *FloatFilterInput   `json:"not,omitempty"`
	Eq      *float64            `json:"eq,omitempty"`
	Ne      *float64            `json:"ne,omitempty"`
	Gt      *float64            `json:"gt,omitempty"`
	Gte     *float64            `json:"gte,omitempty"`
	Lt      *float64            `json:"lt,omitempty"`
	Lte     *float64            `json:"lte,omitempty"`
	Null    *bool               `json:"null,omitempty"`
	NotNull *bool               `json:"notNull,omitempty"`
	In      []*float64          `json:"in,omitempty"`
	NotIn   []*float64          `json:"notIn,omitempty"`
	Between *FloatFilterBetween `json:"between,omitempty"`
}

// ID Filter simple datatypes
type IDFilterInput struct {
	And     []*string      `json:"and,omitempty"`
	Or      []*string      `json:"or,omitempty"`
	Not     *IDFilterInput `json:"not,omitempty"`
	Eq      *string        `json:"eq,omitempty"`
	Ne      *string        `json:"ne,omitempty"`
	Null    *bool          `json:"null,omitempty"`
	NotNull *bool          `json:"notNull,omitempty"`
	In      []*string      `json:"in,omitempty"`
	Notin   []*string      `json:"notin,omitempty"`
}

// Filter between start and end (start > value < end)
type IntFilterBetween struct {
	Start int `json:"start"`
	End   int `json:"end"`
}

// Int Filter simple datatypes
type IntFilterInput struct {
	And     []*int            `json:"and,omitempty"`
	Or      []*int            `json:"or,omitempty"`
	Not     *IntFilterInput   `json:"not,omitempty"`
	Eq      *int              `json:"eq,omitempty"`
	Ne      *int              `json:"ne,omitempty"`
	Gt      *int              `json:"gt,omitempty"`
	Gte     *int              `json:"gte,omitempty"`
	Lt      *int              `json:"lt,omitempty"`
	Lte     *int              `json:"lte,omitempty"`
	Null    *bool             `json:"null,omitempty"`
	NotNull *bool             `json:"notNull,omitempty"`
	In      []*int            `json:"in,omitempty"`
	NotIn   []*int            `json:"notIn,omitempty"`
	Between *IntFilterBetween `json:"between,omitempty"`
}

type Job struct {
	ID             int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt      time.Time                 `json:"createdAt"`
	UpdatedAt      time.Time                 `json:"updatedAt"`
	DeletedAt      *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Title          string                    `json:"title"`
	Industry       *string                   `json:"industry,omitempty"`
	Description    string                    `json:"description"`
	Level          *string                   `json:"level,omitempty"`
	Location       *string                   `json:"location,omitempty"`
	Deadline       *time.Time                `json:"deadline,omitempty"`
	EducationLevel *string                   `json:"educationLevel,omitempty"`
	Experience     *int                      `json:"experience,omitempty"`
	MinSalary      *int                      `json:"minSalary,omitempty"`
	MaxSalary      *int                      `json:"maxSalary,omitempty"`
	Requirements   *string                   `json:"requirements,omitempty"`
	EmployerID     *int                      `json:"employerID,omitempty"`
}

// Filter input selection for Job
// Can be used f.e.: by queryJob
type JobFiltersInput struct {
	ID             *IntFilterInput    `json:"id,omitempty"`
	CreatedAt      *TimeFilterInput   `json:"createdAt,omitempty"`
	UpdatedAt      *TimeFilterInput   `json:"updatedAt,omitempty"`
	Title          *StringFilterInput `json:"title,omitempty"`
	Industry       *StringFilterInput `json:"industry,omitempty"`
	Description    *StringFilterInput `json:"description,omitempty"`
	Level          *StringFilterInput `json:"level,omitempty"`
	Location       *StringFilterInput `json:"location,omitempty"`
	Deadline       *TimeFilterInput   `json:"deadline,omitempty"`
	EducationLevel *StringFilterInput `json:"educationLevel,omitempty"`
	Experience     *IntFilterInput    `json:"experience,omitempty"`
	MinSalary      *IntFilterInput    `json:"minSalary,omitempty"`
	MaxSalary      *IntFilterInput    `json:"maxSalary,omitempty"`
	Requirements   *StringFilterInput `json:"requirements,omitempty"`
	EmployerID     *IntFilterInput    `json:"employerID,omitempty"`
	And            []*JobFiltersInput `json:"and,omitempty"`
	Or             []*JobFiltersInput `json:"or,omitempty"`
	Not            *JobFiltersInput   `json:"not,omitempty"`
}

// Job Input value to add new Job
type JobInput struct {
	Title          string     `json:"title"`
	Industry       *string    `json:"industry,omitempty"`
	Description    string     `json:"description"`
	Level          *string    `json:"level,omitempty"`
	Location       *string    `json:"location,omitempty"`
	Deadline       *time.Time `json:"deadline,omitempty"`
	EducationLevel *string    `json:"educationLevel,omitempty"`
	Experience     *int       `json:"experience,omitempty"`
	MinSalary      *int       `json:"minSalary,omitempty"`
	MaxSalary      *int       `json:"maxSalary,omitempty"`
	Requirements   *string    `json:"requirements,omitempty"`
	EmployerID     *int       `json:"employerID,omitempty"`
}

// Order Job by asc or desc
type JobOrder struct {
	Asc  *JobOrderable `json:"asc,omitempty"`
	Desc *JobOrderable `json:"desc,omitempty"`
}

// Job Patch value all values are optional to update Job entities
type JobPatch struct {
	Title          *string    `json:"title,omitempty"`
	Industry       *string    `json:"industry,omitempty"`
	Description    *string    `json:"description,omitempty"`
	Level          *string    `json:"level,omitempty"`
	Location       *string    `json:"location,omitempty"`
	Deadline       *time.Time `json:"deadline,omitempty"`
	EducationLevel *string    `json:"educationLevel,omitempty"`
	Experience     *int       `json:"experience,omitempty"`
	MinSalary      *int       `json:"minSalary,omitempty"`
	MaxSalary      *int       `json:"maxSalary,omitempty"`
	Requirements   *string    `json:"requirements,omitempty"`
	EmployerID     *int       `json:"employerID,omitempty"`
}

type JobProfile struct {
	ID             int                       `json:"id"`
	CreatedAt      time.Time                 `json:"createdAt"`
	UpdatedAt      time.Time                 `json:"updatedAt"`
	DeletedAt      *runtimehelper.SoftDelete `json:"deletedAt,omitempty"`
	Title          string                    `json:"title"`
	Industry       *string                   `json:"industry,omitempty"`
	Description    string                    `json:"description"`
	Level          *string                   `json:"level,omitempty"`
	Location       *string                   `json:"location,omitempty"`
	Deadline       *time.Time                `json:"deadline,omitempty"`
	EducationLevel *string                   `json:"educationLevel,omitempty"`
	Experience     *int                      `json:"experience,omitempty"`
	MinSalary      *int                      `json:"minSalary,omitempty"`
	MaxSalary      *int                      `json:"maxSalary,omitempty"`
	Requirements   []string                  `json:"requirements,omitempty"`
	Employer       *EmployerProfile          `json:"employer,omitempty"`
}

// Job result
type JobQueryResult struct {
	Data       []*Job `json:"data"`
	Count      int    `json:"count"`
	TotalCount int    `json:"totalCount"`
}

type JobsFilterParameters struct {
	EducationLevel *string `json:"educationLevel,omitempty"`
	Industry       *string `json:"industry,omitempty"`
	Experience     *int    `json:"experience,omitempty"`
}

type Mutation struct {
}

type NewAdmin struct {
	Name        string `json:"name"`
	PhoneNumber string `json:"phone_number"`
	Password    string `json:"password"`
}

type NewEmployee struct {
	Name           string  `json:"name"`
	PhoneNumber    string  `json:"phone_number"`
	Password       string  `json:"password"`
	Profilepicture *string `json:"profilepicture,omitempty"`
}

type NewEmployer struct {
	Name        string  `json:"name"`
	PhoneNumber string  `json:"phone_number"`
	Password    string  `json:"password"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

type NewJob struct {
	Title          string     `json:"title"`
	Description    string     `json:"description"`
	Industry       *string    `json:"industry,omitempty"`
	Level          *string    `json:"level,omitempty"`
	Location       *string    `json:"location,omitempty"`
	Deadline       *time.Time `json:"deadline,omitempty"`
	EducationLevel *string    `json:"educationLevel,omitempty"`
	Experience     *int       `json:"experience,omitempty"`
	MinSalary      *int       `json:"minSalary,omitempty"`
	MaxSalary      *int       `json:"maxSalary,omitempty"`
	Requirements   []string   `json:"requirements,omitempty"`
	EmployerID     *int       `json:"employerID,omitempty"`
}

type PhoneNumberExists struct {
	Verified   bool `json:"verified"`
	Unverified bool `json:"unverified"`
}

type Query struct {
}

type RefreshTokenInput struct {
	Token string `json:"Token"`
}

type SendCodeStatus struct {
	PhoneNumber string `json:"phone_number"`
	Success     bool   `json:"success"`
}

// SoftDelete Filter simple datatypes
type SoftDeleteFilterInput struct {
	And     []*time.Time           `json:"and,omitempty"`
	Or      []*time.Time           `json:"or,omitempty"`
	Not     *SoftDeleteFilterInput `json:"not,omitempty"`
	Eq      *time.Time             `json:"eq,omitempty"`
	Ne      *time.Time             `json:"ne,omitempty"`
	Gt      *time.Time             `json:"gt,omitempty"`
	Gte     *time.Time             `json:"gte,omitempty"`
	Lt      *time.Time             `json:"lt,omitempty"`
	Lte     *time.Time             `json:"lte,omitempty"`
	Null    *bool                  `json:"null,omitempty"`
	NotNull *bool                  `json:"notNull,omitempty"`
	In      []*time.Time           `json:"in,omitempty"`
	NotIn   []*time.Time           `json:"notIn,omitempty"`
	Between *TimeFilterBetween     `json:"between,omitempty"`
}

type SQLCreateExtension struct {
	Value        bool     `json:"value"`
	DirectiveExt []string `json:"directiveExt,omitempty"`
}

type SQLMutationParams struct {
	Add          *SQLCreateExtension `json:"add,omitempty"`
	Update       *SQLCreateExtension `json:"update,omitempty"`
	Delete       *SQLCreateExtension `json:"delete,omitempty"`
	DirectiveExt []string            `json:"directiveExt,omitempty"`
}

type SQLQueryParams struct {
	Get          *SQLCreateExtension `json:"get,omitempty"`
	Query        *SQLCreateExtension `json:"query,omitempty"`
	DirectiveExt []string            `json:"directiveExt,omitempty"`
}

// String Filter simple datatypes
type StringFilterInput struct {
	And          []*string          `json:"and,omitempty"`
	Or           []*string          `json:"or,omitempty"`
	Not          *StringFilterInput `json:"not,omitempty"`
	Eq           *string            `json:"eq,omitempty"`
	Eqi          *string            `json:"eqi,omitempty"`
	Ne           *string            `json:"ne,omitempty"`
	StartsWith   *string            `json:"startsWith,omitempty"`
	EndsWith     *string            `json:"endsWith,omitempty"`
	Contains     *string            `json:"contains,omitempty"`
	NotContains  *string            `json:"notContains,omitempty"`
	Containsi    *string            `json:"containsi,omitempty"`
	NotContainsi *string            `json:"notContainsi,omitempty"`
	Null         *bool              `json:"null,omitempty"`
	NotNull      *bool              `json:"notNull,omitempty"`
	In           []*string          `json:"in,omitempty"`
	NotIn        []*string          `json:"notIn,omitempty"`
}

// Filter between start and end (start > value < end)
type TimeFilterBetween struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

// Time Filter simple datatypes
type TimeFilterInput struct {
	And     []*time.Time       `json:"and,omitempty"`
	Or      []*time.Time       `json:"or,omitempty"`
	Not     *TimeFilterInput   `json:"not,omitempty"`
	Eq      *time.Time         `json:"eq,omitempty"`
	Ne      *time.Time         `json:"ne,omitempty"`
	Gt      *time.Time         `json:"gt,omitempty"`
	Gte     *time.Time         `json:"gte,omitempty"`
	Lt      *time.Time         `json:"lt,omitempty"`
	Lte     *time.Time         `json:"lte,omitempty"`
	Null    *bool              `json:"null,omitempty"`
	NotNull *bool              `json:"notNull,omitempty"`
	In      []*time.Time       `json:"in,omitempty"`
	NotIn   []*time.Time       `json:"notIn,omitempty"`
	Between *TimeFilterBetween `json:"between,omitempty"`
}

type UnapprovedJob struct {
	ID             int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt      time.Time                 `json:"createdAt"`
	UpdatedAt      time.Time                 `json:"updatedAt"`
	DeletedAt      *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Title          string                    `json:"title"`
	Industry       *string                   `json:"industry,omitempty"`
	Description    string                    `json:"description"`
	Level          *string                   `json:"level,omitempty"`
	Location       *string                   `json:"location,omitempty"`
	Deadline       *time.Time                `json:"deadline,omitempty"`
	EducationLevel *string                   `json:"educationLevel,omitempty"`
	Experience     *int                      `json:"experience,omitempty"`
	MinSalary      *int                      `json:"minSalary,omitempty"`
	MaxSalary      *int                      `json:"maxSalary,omitempty"`
	Requirements   *string                   `json:"requirements,omitempty"`
	EmployerID     *int                      `json:"employerID,omitempty"`
}

// Filter input selection for UnapprovedJob
// Can be used f.e.: by queryUnapprovedJob
type UnapprovedJobFiltersInput struct {
	ID             *IntFilterInput              `json:"id,omitempty"`
	CreatedAt      *TimeFilterInput             `json:"createdAt,omitempty"`
	UpdatedAt      *TimeFilterInput             `json:"updatedAt,omitempty"`
	Title          *StringFilterInput           `json:"title,omitempty"`
	Industry       *StringFilterInput           `json:"industry,omitempty"`
	Description    *StringFilterInput           `json:"description,omitempty"`
	Level          *StringFilterInput           `json:"level,omitempty"`
	Location       *StringFilterInput           `json:"location,omitempty"`
	Deadline       *TimeFilterInput             `json:"deadline,omitempty"`
	EducationLevel *StringFilterInput           `json:"educationLevel,omitempty"`
	Experience     *IntFilterInput              `json:"experience,omitempty"`
	MinSalary      *IntFilterInput              `json:"minSalary,omitempty"`
	MaxSalary      *IntFilterInput              `json:"maxSalary,omitempty"`
	Requirements   *StringFilterInput           `json:"requirements,omitempty"`
	EmployerID     *IntFilterInput              `json:"employerID,omitempty"`
	And            []*UnapprovedJobFiltersInput `json:"and,omitempty"`
	Or             []*UnapprovedJobFiltersInput `json:"or,omitempty"`
	Not            *UnapprovedJobFiltersInput   `json:"not,omitempty"`
}

// UnapprovedJob Input value to add new UnapprovedJob
type UnapprovedJobInput struct {
	Title          string     `json:"title"`
	Industry       *string    `json:"industry,omitempty"`
	Description    string     `json:"description"`
	Level          *string    `json:"level,omitempty"`
	Location       *string    `json:"location,omitempty"`
	Deadline       *time.Time `json:"deadline,omitempty"`
	EducationLevel *string    `json:"educationLevel,omitempty"`
	Experience     *int       `json:"experience,omitempty"`
	MinSalary      *int       `json:"minSalary,omitempty"`
	MaxSalary      *int       `json:"maxSalary,omitempty"`
	Requirements   *string    `json:"requirements,omitempty"`
	EmployerID     *int       `json:"employerID,omitempty"`
}

// Order UnapprovedJob by asc or desc
type UnapprovedJobOrder struct {
	Asc  *UnapprovedJobOrderable `json:"asc,omitempty"`
	Desc *UnapprovedJobOrderable `json:"desc,omitempty"`
}

// UnapprovedJob Patch value all values are optional to update UnapprovedJob entities
type UnapprovedJobPatch struct {
	Title          *string    `json:"title,omitempty"`
	Industry       *string    `json:"industry,omitempty"`
	Description    *string    `json:"description,omitempty"`
	Level          *string    `json:"level,omitempty"`
	Location       *string    `json:"location,omitempty"`
	Deadline       *time.Time `json:"deadline,omitempty"`
	EducationLevel *string    `json:"educationLevel,omitempty"`
	Experience     *int       `json:"experience,omitempty"`
	MinSalary      *int       `json:"minSalary,omitempty"`
	MaxSalary      *int       `json:"maxSalary,omitempty"`
	Requirements   *string    `json:"requirements,omitempty"`
	EmployerID     *int       `json:"employerID,omitempty"`
}

// UnapprovedJob result
type UnapprovedJobQueryResult struct {
	Data       []*UnapprovedJob `json:"data"`
	Count      int              `json:"count"`
	TotalCount int              `json:"totalCount"`
}

type UnverifiedAdmin struct {
	ID          int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt   time.Time                 `json:"createdAt"`
	UpdatedAt   time.Time                 `json:"updatedAt"`
	DeletedAt   *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Name        string                    `json:"name"`
	PhoneNumber string                    `json:"phone_number"`
	Password    string                    `json:"password"`
}

// Filter input selection for UnverifiedAdmin
// Can be used f.e.: by queryUnverifiedAdmin
type UnverifiedAdminFiltersInput struct {
	ID          *IntFilterInput                `json:"id,omitempty"`
	CreatedAt   *TimeFilterInput               `json:"createdAt,omitempty"`
	UpdatedAt   *TimeFilterInput               `json:"updatedAt,omitempty"`
	Name        *StringFilterInput             `json:"name,omitempty"`
	PhoneNumber *StringFilterInput             `json:"phone_number,omitempty"`
	Password    *StringFilterInput             `json:"password,omitempty"`
	And         []*UnverifiedAdminFiltersInput `json:"and,omitempty"`
	Or          []*UnverifiedAdminFiltersInput `json:"or,omitempty"`
	Not         *UnverifiedAdminFiltersInput   `json:"not,omitempty"`
}

// UnverifiedAdmin Input value to add new UnverifiedAdmin
type UnverifiedAdminInput struct {
	Name        string `json:"name"`
	PhoneNumber string `json:"phone_number"`
	Password    string `json:"password"`
}

// Order UnverifiedAdmin by asc or desc
type UnverifiedAdminOrder struct {
	Asc  *UnverifiedAdminOrderable `json:"asc,omitempty"`
	Desc *UnverifiedAdminOrderable `json:"desc,omitempty"`
}

// UnverifiedAdmin Patch value all values are optional to update UnverifiedAdmin entities
type UnverifiedAdminPatch struct {
	Name        *string `json:"name,omitempty"`
	PhoneNumber *string `json:"phone_number,omitempty"`
	Password    *string `json:"password,omitempty"`
}

// UnverifiedAdmin result
type UnverifiedAdminQueryResult struct {
	Data       []*UnverifiedAdmin `json:"data"`
	Count      int                `json:"count"`
	TotalCount int                `json:"totalCount"`
}

type UnverifiedEmployee struct {
	ID             int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt      time.Time                 `json:"createdAt"`
	UpdatedAt      time.Time                 `json:"updatedAt"`
	DeletedAt      *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Name           string                    `json:"name"`
	PhoneNumber    string                    `json:"phone_number"`
	Password       string                    `json:"password"`
	Profilepicture *string                   `json:"profilepicture,omitempty"`
}

// Filter input selection for UnverifiedEmployee
// Can be used f.e.: by queryUnverifiedEmployee
type UnverifiedEmployeeFiltersInput struct {
	ID             *IntFilterInput                   `json:"id,omitempty"`
	CreatedAt      *TimeFilterInput                  `json:"createdAt,omitempty"`
	UpdatedAt      *TimeFilterInput                  `json:"updatedAt,omitempty"`
	Name           *StringFilterInput                `json:"name,omitempty"`
	PhoneNumber    *StringFilterInput                `json:"phone_number,omitempty"`
	Password       *StringFilterInput                `json:"password,omitempty"`
	Profilepicture *StringFilterInput                `json:"profilepicture,omitempty"`
	And            []*UnverifiedEmployeeFiltersInput `json:"and,omitempty"`
	Or             []*UnverifiedEmployeeFiltersInput `json:"or,omitempty"`
	Not            *UnverifiedEmployeeFiltersInput   `json:"not,omitempty"`
}

// UnverifiedEmployee Input value to add new UnverifiedEmployee
type UnverifiedEmployeeInput struct {
	Name           string  `json:"name"`
	PhoneNumber    string  `json:"phone_number"`
	Password       string  `json:"password"`
	Profilepicture *string `json:"profilepicture,omitempty"`
}

// Order UnverifiedEmployee by asc or desc
type UnverifiedEmployeeOrder struct {
	Asc  *UnverifiedEmployeeOrderable `json:"asc,omitempty"`
	Desc *UnverifiedEmployeeOrderable `json:"desc,omitempty"`
}

// UnverifiedEmployee Patch value all values are optional to update UnverifiedEmployee entities
type UnverifiedEmployeePatch struct {
	Name           *string `json:"name,omitempty"`
	PhoneNumber    *string `json:"phone_number,omitempty"`
	Password       *string `json:"password,omitempty"`
	Profilepicture *string `json:"profilepicture,omitempty"`
}

// UnverifiedEmployee result
type UnverifiedEmployeeQueryResult struct {
	Data       []*UnverifiedEmployee `json:"data"`
	Count      int                   `json:"count"`
	TotalCount int                   `json:"totalCount"`
}

type UnverifiedEmployer struct {
	ID          int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt   time.Time                 `json:"createdAt"`
	UpdatedAt   time.Time                 `json:"updatedAt"`
	DeletedAt   *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Name        string                    `json:"name"`
	PhoneNumber string                    `json:"phone_number"`
	Password    string                    `json:"password"`
	Badge       *string                   `json:"badge,omitempty"`
	Website     *string                   `json:"Website,omitempty"`
}

// Filter input selection for UnverifiedEmployer
// Can be used f.e.: by queryUnverifiedEmployer
type UnverifiedEmployerFiltersInput struct {
	ID          *IntFilterInput                   `json:"id,omitempty"`
	CreatedAt   *TimeFilterInput                  `json:"createdAt,omitempty"`
	UpdatedAt   *TimeFilterInput                  `json:"updatedAt,omitempty"`
	Name        *StringFilterInput                `json:"name,omitempty"`
	PhoneNumber *StringFilterInput                `json:"phone_number,omitempty"`
	Password    *StringFilterInput                `json:"password,omitempty"`
	Badge       *StringFilterInput                `json:"badge,omitempty"`
	Website     *StringFilterInput                `json:"Website,omitempty"`
	And         []*UnverifiedEmployerFiltersInput `json:"and,omitempty"`
	Or          []*UnverifiedEmployerFiltersInput `json:"or,omitempty"`
	Not         *UnverifiedEmployerFiltersInput   `json:"not,omitempty"`
}

// UnverifiedEmployer Input value to add new UnverifiedEmployer
type UnverifiedEmployerInput struct {
	Name        string  `json:"name"`
	PhoneNumber string  `json:"phone_number"`
	Password    string  `json:"password"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

// Order UnverifiedEmployer by asc or desc
type UnverifiedEmployerOrder struct {
	Asc  *UnverifiedEmployerOrderable `json:"asc,omitempty"`
	Desc *UnverifiedEmployerOrderable `json:"desc,omitempty"`
}

// UnverifiedEmployer Patch value all values are optional to update UnverifiedEmployer entities
type UnverifiedEmployerPatch struct {
	Name        *string `json:"name,omitempty"`
	PhoneNumber *string `json:"phone_number,omitempty"`
	Password    *string `json:"password,omitempty"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

// UnverifiedEmployer result
type UnverifiedEmployerQueryResult struct {
	Data       []*UnverifiedEmployer `json:"data"`
	Count      int                   `json:"count"`
	TotalCount int                   `json:"totalCount"`
}

// Update rules for Admin multiupdates simple possible by global filtervalue
type UpdateAdminInput struct {
	Filter *AdminFiltersInput `json:"filter"`
	Set    *AdminPatch        `json:"set"`
}

// UpdateAdmin result with filterable data and affected rows
type UpdateAdminPayload struct {
	Admin *AdminQueryResult `json:"admin"`
	// Count of affected updates
	Count    int      `json:"count"`
	Affected []*Admin `json:"affected"`
}

// Update rules for Employee multiupdates simple possible by global filtervalue
type UpdateEmployeeInput struct {
	Filter *EmployeeFiltersInput `json:"filter"`
	Set    *EmployeePatch        `json:"set"`
}

// UpdateEmployee result with filterable data and affected rows
type UpdateEmployeePayload struct {
	Employee *EmployeeQueryResult `json:"employee"`
	// Count of affected updates
	Count    int         `json:"count"`
	Affected []*Employee `json:"affected"`
}

// Update rules for Employer multiupdates simple possible by global filtervalue
type UpdateEmployerInput struct {
	Filter *EmployerFiltersInput `json:"filter"`
	Set    *EmployerPatch        `json:"set"`
}

// UpdateEmployer result with filterable data and affected rows
type UpdateEmployerPayload struct {
	Employer *EmployerQueryResult `json:"employer"`
	// Count of affected updates
	Count    int         `json:"count"`
	Affected []*Employer `json:"affected"`
}

// Update rules for Job multiupdates simple possible by global filtervalue
type UpdateJobInput struct {
	Filter *JobFiltersInput `json:"filter"`
	Set    *JobPatch        `json:"set"`
}

// UpdateJob result with filterable data and affected rows
type UpdateJobPayload struct {
	Job *JobQueryResult `json:"job"`
	// Count of affected updates
	Count    int    `json:"count"`
	Affected []*Job `json:"affected"`
}

// Update rules for UnapprovedJob multiupdates simple possible by global filtervalue
type UpdateUnapprovedJobInput struct {
	Filter *UnapprovedJobFiltersInput `json:"filter"`
	Set    *UnapprovedJobPatch        `json:"set"`
}

// UpdateUnapprovedJob result with filterable data and affected rows
type UpdateUnapprovedJobPayload struct {
	UnapprovedJob *UnapprovedJobQueryResult `json:"unapprovedJob"`
	// Count of affected updates
	Count    int              `json:"count"`
	Affected []*UnapprovedJob `json:"affected"`
}

// Update rules for UnverifiedAdmin multiupdates simple possible by global filtervalue
type UpdateUnverifiedAdminInput struct {
	Filter *UnverifiedAdminFiltersInput `json:"filter"`
	Set    *UnverifiedAdminPatch        `json:"set"`
}

// UpdateUnverifiedAdmin result with filterable data and affected rows
type UpdateUnverifiedAdminPayload struct {
	UnverifiedAdmin *UnverifiedAdminQueryResult `json:"unverifiedAdmin"`
	// Count of affected updates
	Count    int                `json:"count"`
	Affected []*UnverifiedAdmin `json:"affected"`
}

// Update rules for UnverifiedEmployee multiupdates simple possible by global filtervalue
type UpdateUnverifiedEmployeeInput struct {
	Filter *UnverifiedEmployeeFiltersInput `json:"filter"`
	Set    *UnverifiedEmployeePatch        `json:"set"`
}

// UpdateUnverifiedEmployee result with filterable data and affected rows
type UpdateUnverifiedEmployeePayload struct {
	UnverifiedEmployee *UnverifiedEmployeeQueryResult `json:"unverifiedEmployee"`
	// Count of affected updates
	Count    int                   `json:"count"`
	Affected []*UnverifiedEmployee `json:"affected"`
}

// Update rules for UnverifiedEmployer multiupdates simple possible by global filtervalue
type UpdateUnverifiedEmployerInput struct {
	Filter *UnverifiedEmployerFiltersInput `json:"filter"`
	Set    *UnverifiedEmployerPatch        `json:"set"`
}

// UpdateUnverifiedEmployer result with filterable data and affected rows
type UpdateUnverifiedEmployerPayload struct {
	UnverifiedEmployer *UnverifiedEmployerQueryResult `json:"unverifiedEmployer"`
	// Count of affected updates
	Count    int                   `json:"count"`
	Affected []*UnverifiedEmployer `json:"affected"`
}

type Verificationinfo struct {
	PhoneNumber string `json:"phone_number"`
	Otp         string `json:"otp"`
}

// Groupable data for  Admin
// Can be used f.e.: by queryAdmin
type AdminGroup string

const (
	AdminGroupID          AdminGroup = "id"
	AdminGroupCreatedAt   AdminGroup = "createdAt"
	AdminGroupUpdatedAt   AdminGroup = "updatedAt"
	AdminGroupName        AdminGroup = "name"
	AdminGroupPhoneNumber AdminGroup = "phone_number"
	AdminGroupPassword    AdminGroup = "password"
)

var AllAdminGroup = []AdminGroup{
	AdminGroupID,
	AdminGroupCreatedAt,
	AdminGroupUpdatedAt,
	AdminGroupName,
	AdminGroupPhoneNumber,
	AdminGroupPassword,
}

func (e AdminGroup) IsValid() bool {
	switch e {
	case AdminGroupID, AdminGroupCreatedAt, AdminGroupUpdatedAt, AdminGroupName, AdminGroupPhoneNumber, AdminGroupPassword:
		return true
	}
	return false
}

func (e AdminGroup) String() string {
	return string(e)
}

func (e *AdminGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdminGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AdminGroup", str)
	}
	return nil
}

func (e AdminGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for Admin a enum of all orderable entities
// can be used f.e.: queryAdmin
type AdminOrderable string

const (
	AdminOrderableID          AdminOrderable = "id"
	AdminOrderableName        AdminOrderable = "name"
	AdminOrderablePhoneNumber AdminOrderable = "phone_number"
	AdminOrderablePassword    AdminOrderable = "password"
)

var AllAdminOrderable = []AdminOrderable{
	AdminOrderableID,
	AdminOrderableName,
	AdminOrderablePhoneNumber,
	AdminOrderablePassword,
}

func (e AdminOrderable) IsValid() bool {
	switch e {
	case AdminOrderableID, AdminOrderableName, AdminOrderablePhoneNumber, AdminOrderablePassword:
		return true
	}
	return false
}

func (e AdminOrderable) String() string {
	return string(e)
}

func (e *AdminOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdminOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AdminOrderable", str)
	}
	return nil
}

func (e AdminOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  Employee
// Can be used f.e.: by queryEmployee
type EmployeeGroup string

const (
	EmployeeGroupID             EmployeeGroup = "id"
	EmployeeGroupCreatedAt      EmployeeGroup = "createdAt"
	EmployeeGroupUpdatedAt      EmployeeGroup = "updatedAt"
	EmployeeGroupName           EmployeeGroup = "name"
	EmployeeGroupPhoneNumber    EmployeeGroup = "phone_number"
	EmployeeGroupPassword       EmployeeGroup = "password"
	EmployeeGroupProfilepicture EmployeeGroup = "profilepicture"
)

var AllEmployeeGroup = []EmployeeGroup{
	EmployeeGroupID,
	EmployeeGroupCreatedAt,
	EmployeeGroupUpdatedAt,
	EmployeeGroupName,
	EmployeeGroupPhoneNumber,
	EmployeeGroupPassword,
	EmployeeGroupProfilepicture,
}

func (e EmployeeGroup) IsValid() bool {
	switch e {
	case EmployeeGroupID, EmployeeGroupCreatedAt, EmployeeGroupUpdatedAt, EmployeeGroupName, EmployeeGroupPhoneNumber, EmployeeGroupPassword, EmployeeGroupProfilepicture:
		return true
	}
	return false
}

func (e EmployeeGroup) String() string {
	return string(e)
}

func (e *EmployeeGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmployeeGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmployeeGroup", str)
	}
	return nil
}

func (e EmployeeGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for Employee a enum of all orderable entities
// can be used f.e.: queryEmployee
type EmployeeOrderable string

const (
	EmployeeOrderableID             EmployeeOrderable = "id"
	EmployeeOrderableName           EmployeeOrderable = "name"
	EmployeeOrderablePhoneNumber    EmployeeOrderable = "phone_number"
	EmployeeOrderablePassword       EmployeeOrderable = "password"
	EmployeeOrderableProfilepicture EmployeeOrderable = "profilepicture"
)

var AllEmployeeOrderable = []EmployeeOrderable{
	EmployeeOrderableID,
	EmployeeOrderableName,
	EmployeeOrderablePhoneNumber,
	EmployeeOrderablePassword,
	EmployeeOrderableProfilepicture,
}

func (e EmployeeOrderable) IsValid() bool {
	switch e {
	case EmployeeOrderableID, EmployeeOrderableName, EmployeeOrderablePhoneNumber, EmployeeOrderablePassword, EmployeeOrderableProfilepicture:
		return true
	}
	return false
}

func (e EmployeeOrderable) String() string {
	return string(e)
}

func (e *EmployeeOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmployeeOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmployeeOrderable", str)
	}
	return nil
}

func (e EmployeeOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  Employer
// Can be used f.e.: by queryEmployer
type EmployerGroup string

const (
	EmployerGroupID          EmployerGroup = "id"
	EmployerGroupCreatedAt   EmployerGroup = "createdAt"
	EmployerGroupUpdatedAt   EmployerGroup = "updatedAt"
	EmployerGroupName        EmployerGroup = "name"
	EmployerGroupPhoneNumber EmployerGroup = "phone_number"
	EmployerGroupPassword    EmployerGroup = "password"
	EmployerGroupBadge       EmployerGroup = "badge"
	EmployerGroupWebsite     EmployerGroup = "Website"
)

var AllEmployerGroup = []EmployerGroup{
	EmployerGroupID,
	EmployerGroupCreatedAt,
	EmployerGroupUpdatedAt,
	EmployerGroupName,
	EmployerGroupPhoneNumber,
	EmployerGroupPassword,
	EmployerGroupBadge,
	EmployerGroupWebsite,
}

func (e EmployerGroup) IsValid() bool {
	switch e {
	case EmployerGroupID, EmployerGroupCreatedAt, EmployerGroupUpdatedAt, EmployerGroupName, EmployerGroupPhoneNumber, EmployerGroupPassword, EmployerGroupBadge, EmployerGroupWebsite:
		return true
	}
	return false
}

func (e EmployerGroup) String() string {
	return string(e)
}

func (e *EmployerGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmployerGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmployerGroup", str)
	}
	return nil
}

func (e EmployerGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for Employer a enum of all orderable entities
// can be used f.e.: queryEmployer
type EmployerOrderable string

const (
	EmployerOrderableID          EmployerOrderable = "id"
	EmployerOrderableName        EmployerOrderable = "name"
	EmployerOrderablePhoneNumber EmployerOrderable = "phone_number"
	EmployerOrderablePassword    EmployerOrderable = "password"
	EmployerOrderableBadge       EmployerOrderable = "badge"
	EmployerOrderableWebsite     EmployerOrderable = "Website"
)

var AllEmployerOrderable = []EmployerOrderable{
	EmployerOrderableID,
	EmployerOrderableName,
	EmployerOrderablePhoneNumber,
	EmployerOrderablePassword,
	EmployerOrderableBadge,
	EmployerOrderableWebsite,
}

func (e EmployerOrderable) IsValid() bool {
	switch e {
	case EmployerOrderableID, EmployerOrderableName, EmployerOrderablePhoneNumber, EmployerOrderablePassword, EmployerOrderableBadge, EmployerOrderableWebsite:
		return true
	}
	return false
}

func (e EmployerOrderable) String() string {
	return string(e)
}

func (e *EmployerOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmployerOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmployerOrderable", str)
	}
	return nil
}

func (e EmployerOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  Job
// Can be used f.e.: by queryJob
type JobGroup string

const (
	JobGroupID             JobGroup = "id"
	JobGroupCreatedAt      JobGroup = "createdAt"
	JobGroupUpdatedAt      JobGroup = "updatedAt"
	JobGroupTitle          JobGroup = "title"
	JobGroupIndustry       JobGroup = "industry"
	JobGroupDescription    JobGroup = "description"
	JobGroupLevel          JobGroup = "level"
	JobGroupLocation       JobGroup = "location"
	JobGroupDeadline       JobGroup = "deadline"
	JobGroupEducationLevel JobGroup = "educationLevel"
	JobGroupExperience     JobGroup = "experience"
	JobGroupMinSalary      JobGroup = "minSalary"
	JobGroupMaxSalary      JobGroup = "maxSalary"
	JobGroupRequirements   JobGroup = "requirements"
	JobGroupEmployerID     JobGroup = "employerID"
)

var AllJobGroup = []JobGroup{
	JobGroupID,
	JobGroupCreatedAt,
	JobGroupUpdatedAt,
	JobGroupTitle,
	JobGroupIndustry,
	JobGroupDescription,
	JobGroupLevel,
	JobGroupLocation,
	JobGroupDeadline,
	JobGroupEducationLevel,
	JobGroupExperience,
	JobGroupMinSalary,
	JobGroupMaxSalary,
	JobGroupRequirements,
	JobGroupEmployerID,
}

func (e JobGroup) IsValid() bool {
	switch e {
	case JobGroupID, JobGroupCreatedAt, JobGroupUpdatedAt, JobGroupTitle, JobGroupIndustry, JobGroupDescription, JobGroupLevel, JobGroupLocation, JobGroupDeadline, JobGroupEducationLevel, JobGroupExperience, JobGroupMinSalary, JobGroupMaxSalary, JobGroupRequirements, JobGroupEmployerID:
		return true
	}
	return false
}

func (e JobGroup) String() string {
	return string(e)
}

func (e *JobGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobGroup", str)
	}
	return nil
}

func (e JobGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for Job a enum of all orderable entities
// can be used f.e.: queryJob
type JobOrderable string

const (
	JobOrderableID             JobOrderable = "id"
	JobOrderableTitle          JobOrderable = "title"
	JobOrderableIndustry       JobOrderable = "industry"
	JobOrderableDescription    JobOrderable = "description"
	JobOrderableLevel          JobOrderable = "level"
	JobOrderableLocation       JobOrderable = "location"
	JobOrderableEducationLevel JobOrderable = "educationLevel"
	JobOrderableExperience     JobOrderable = "experience"
	JobOrderableMinSalary      JobOrderable = "minSalary"
	JobOrderableMaxSalary      JobOrderable = "maxSalary"
	JobOrderableRequirements   JobOrderable = "requirements"
	JobOrderableEmployerID     JobOrderable = "employerID"
)

var AllJobOrderable = []JobOrderable{
	JobOrderableID,
	JobOrderableTitle,
	JobOrderableIndustry,
	JobOrderableDescription,
	JobOrderableLevel,
	JobOrderableLocation,
	JobOrderableEducationLevel,
	JobOrderableExperience,
	JobOrderableMinSalary,
	JobOrderableMaxSalary,
	JobOrderableRequirements,
	JobOrderableEmployerID,
}

func (e JobOrderable) IsValid() bool {
	switch e {
	case JobOrderableID, JobOrderableTitle, JobOrderableIndustry, JobOrderableDescription, JobOrderableLevel, JobOrderableLocation, JobOrderableEducationLevel, JobOrderableExperience, JobOrderableMinSalary, JobOrderableMaxSalary, JobOrderableRequirements, JobOrderableEmployerID:
		return true
	}
	return false
}

func (e JobOrderable) String() string {
	return string(e)
}

func (e *JobOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobOrderable", str)
	}
	return nil
}

func (e JobOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  UnapprovedJob
// Can be used f.e.: by queryUnapprovedJob
type UnapprovedJobGroup string

const (
	UnapprovedJobGroupID             UnapprovedJobGroup = "id"
	UnapprovedJobGroupCreatedAt      UnapprovedJobGroup = "createdAt"
	UnapprovedJobGroupUpdatedAt      UnapprovedJobGroup = "updatedAt"
	UnapprovedJobGroupTitle          UnapprovedJobGroup = "title"
	UnapprovedJobGroupIndustry       UnapprovedJobGroup = "industry"
	UnapprovedJobGroupDescription    UnapprovedJobGroup = "description"
	UnapprovedJobGroupLevel          UnapprovedJobGroup = "level"
	UnapprovedJobGroupLocation       UnapprovedJobGroup = "location"
	UnapprovedJobGroupDeadline       UnapprovedJobGroup = "deadline"
	UnapprovedJobGroupEducationLevel UnapprovedJobGroup = "educationLevel"
	UnapprovedJobGroupExperience     UnapprovedJobGroup = "experience"
	UnapprovedJobGroupMinSalary      UnapprovedJobGroup = "minSalary"
	UnapprovedJobGroupMaxSalary      UnapprovedJobGroup = "maxSalary"
	UnapprovedJobGroupRequirements   UnapprovedJobGroup = "requirements"
	UnapprovedJobGroupEmployerID     UnapprovedJobGroup = "employerID"
)

var AllUnapprovedJobGroup = []UnapprovedJobGroup{
	UnapprovedJobGroupID,
	UnapprovedJobGroupCreatedAt,
	UnapprovedJobGroupUpdatedAt,
	UnapprovedJobGroupTitle,
	UnapprovedJobGroupIndustry,
	UnapprovedJobGroupDescription,
	UnapprovedJobGroupLevel,
	UnapprovedJobGroupLocation,
	UnapprovedJobGroupDeadline,
	UnapprovedJobGroupEducationLevel,
	UnapprovedJobGroupExperience,
	UnapprovedJobGroupMinSalary,
	UnapprovedJobGroupMaxSalary,
	UnapprovedJobGroupRequirements,
	UnapprovedJobGroupEmployerID,
}

func (e UnapprovedJobGroup) IsValid() bool {
	switch e {
	case UnapprovedJobGroupID, UnapprovedJobGroupCreatedAt, UnapprovedJobGroupUpdatedAt, UnapprovedJobGroupTitle, UnapprovedJobGroupIndustry, UnapprovedJobGroupDescription, UnapprovedJobGroupLevel, UnapprovedJobGroupLocation, UnapprovedJobGroupDeadline, UnapprovedJobGroupEducationLevel, UnapprovedJobGroupExperience, UnapprovedJobGroupMinSalary, UnapprovedJobGroupMaxSalary, UnapprovedJobGroupRequirements, UnapprovedJobGroupEmployerID:
		return true
	}
	return false
}

func (e UnapprovedJobGroup) String() string {
	return string(e)
}

func (e *UnapprovedJobGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnapprovedJobGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnapprovedJobGroup", str)
	}
	return nil
}

func (e UnapprovedJobGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for UnapprovedJob a enum of all orderable entities
// can be used f.e.: queryUnapprovedJob
type UnapprovedJobOrderable string

const (
	UnapprovedJobOrderableID             UnapprovedJobOrderable = "id"
	UnapprovedJobOrderableTitle          UnapprovedJobOrderable = "title"
	UnapprovedJobOrderableIndustry       UnapprovedJobOrderable = "industry"
	UnapprovedJobOrderableDescription    UnapprovedJobOrderable = "description"
	UnapprovedJobOrderableLevel          UnapprovedJobOrderable = "level"
	UnapprovedJobOrderableLocation       UnapprovedJobOrderable = "location"
	UnapprovedJobOrderableEducationLevel UnapprovedJobOrderable = "educationLevel"
	UnapprovedJobOrderableExperience     UnapprovedJobOrderable = "experience"
	UnapprovedJobOrderableMinSalary      UnapprovedJobOrderable = "minSalary"
	UnapprovedJobOrderableMaxSalary      UnapprovedJobOrderable = "maxSalary"
	UnapprovedJobOrderableRequirements   UnapprovedJobOrderable = "requirements"
	UnapprovedJobOrderableEmployerID     UnapprovedJobOrderable = "employerID"
)

var AllUnapprovedJobOrderable = []UnapprovedJobOrderable{
	UnapprovedJobOrderableID,
	UnapprovedJobOrderableTitle,
	UnapprovedJobOrderableIndustry,
	UnapprovedJobOrderableDescription,
	UnapprovedJobOrderableLevel,
	UnapprovedJobOrderableLocation,
	UnapprovedJobOrderableEducationLevel,
	UnapprovedJobOrderableExperience,
	UnapprovedJobOrderableMinSalary,
	UnapprovedJobOrderableMaxSalary,
	UnapprovedJobOrderableRequirements,
	UnapprovedJobOrderableEmployerID,
}

func (e UnapprovedJobOrderable) IsValid() bool {
	switch e {
	case UnapprovedJobOrderableID, UnapprovedJobOrderableTitle, UnapprovedJobOrderableIndustry, UnapprovedJobOrderableDescription, UnapprovedJobOrderableLevel, UnapprovedJobOrderableLocation, UnapprovedJobOrderableEducationLevel, UnapprovedJobOrderableExperience, UnapprovedJobOrderableMinSalary, UnapprovedJobOrderableMaxSalary, UnapprovedJobOrderableRequirements, UnapprovedJobOrderableEmployerID:
		return true
	}
	return false
}

func (e UnapprovedJobOrderable) String() string {
	return string(e)
}

func (e *UnapprovedJobOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnapprovedJobOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnapprovedJobOrderable", str)
	}
	return nil
}

func (e UnapprovedJobOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  UnverifiedAdmin
// Can be used f.e.: by queryUnverifiedAdmin
type UnverifiedAdminGroup string

const (
	UnverifiedAdminGroupID          UnverifiedAdminGroup = "id"
	UnverifiedAdminGroupCreatedAt   UnverifiedAdminGroup = "createdAt"
	UnverifiedAdminGroupUpdatedAt   UnverifiedAdminGroup = "updatedAt"
	UnverifiedAdminGroupName        UnverifiedAdminGroup = "name"
	UnverifiedAdminGroupPhoneNumber UnverifiedAdminGroup = "phone_number"
	UnverifiedAdminGroupPassword    UnverifiedAdminGroup = "password"
)

var AllUnverifiedAdminGroup = []UnverifiedAdminGroup{
	UnverifiedAdminGroupID,
	UnverifiedAdminGroupCreatedAt,
	UnverifiedAdminGroupUpdatedAt,
	UnverifiedAdminGroupName,
	UnverifiedAdminGroupPhoneNumber,
	UnverifiedAdminGroupPassword,
}

func (e UnverifiedAdminGroup) IsValid() bool {
	switch e {
	case UnverifiedAdminGroupID, UnverifiedAdminGroupCreatedAt, UnverifiedAdminGroupUpdatedAt, UnverifiedAdminGroupName, UnverifiedAdminGroupPhoneNumber, UnverifiedAdminGroupPassword:
		return true
	}
	return false
}

func (e UnverifiedAdminGroup) String() string {
	return string(e)
}

func (e *UnverifiedAdminGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnverifiedAdminGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnverifiedAdminGroup", str)
	}
	return nil
}

func (e UnverifiedAdminGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for UnverifiedAdmin a enum of all orderable entities
// can be used f.e.: queryUnverifiedAdmin
type UnverifiedAdminOrderable string

const (
	UnverifiedAdminOrderableID          UnverifiedAdminOrderable = "id"
	UnverifiedAdminOrderableName        UnverifiedAdminOrderable = "name"
	UnverifiedAdminOrderablePhoneNumber UnverifiedAdminOrderable = "phone_number"
	UnverifiedAdminOrderablePassword    UnverifiedAdminOrderable = "password"
)

var AllUnverifiedAdminOrderable = []UnverifiedAdminOrderable{
	UnverifiedAdminOrderableID,
	UnverifiedAdminOrderableName,
	UnverifiedAdminOrderablePhoneNumber,
	UnverifiedAdminOrderablePassword,
}

func (e UnverifiedAdminOrderable) IsValid() bool {
	switch e {
	case UnverifiedAdminOrderableID, UnverifiedAdminOrderableName, UnverifiedAdminOrderablePhoneNumber, UnverifiedAdminOrderablePassword:
		return true
	}
	return false
}

func (e UnverifiedAdminOrderable) String() string {
	return string(e)
}

func (e *UnverifiedAdminOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnverifiedAdminOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnverifiedAdminOrderable", str)
	}
	return nil
}

func (e UnverifiedAdminOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  UnverifiedEmployee
// Can be used f.e.: by queryUnverifiedEmployee
type UnverifiedEmployeeGroup string

const (
	UnverifiedEmployeeGroupID             UnverifiedEmployeeGroup = "id"
	UnverifiedEmployeeGroupCreatedAt      UnverifiedEmployeeGroup = "createdAt"
	UnverifiedEmployeeGroupUpdatedAt      UnverifiedEmployeeGroup = "updatedAt"
	UnverifiedEmployeeGroupName           UnverifiedEmployeeGroup = "name"
	UnverifiedEmployeeGroupPhoneNumber    UnverifiedEmployeeGroup = "phone_number"
	UnverifiedEmployeeGroupPassword       UnverifiedEmployeeGroup = "password"
	UnverifiedEmployeeGroupProfilepicture UnverifiedEmployeeGroup = "profilepicture"
)

var AllUnverifiedEmployeeGroup = []UnverifiedEmployeeGroup{
	UnverifiedEmployeeGroupID,
	UnverifiedEmployeeGroupCreatedAt,
	UnverifiedEmployeeGroupUpdatedAt,
	UnverifiedEmployeeGroupName,
	UnverifiedEmployeeGroupPhoneNumber,
	UnverifiedEmployeeGroupPassword,
	UnverifiedEmployeeGroupProfilepicture,
}

func (e UnverifiedEmployeeGroup) IsValid() bool {
	switch e {
	case UnverifiedEmployeeGroupID, UnverifiedEmployeeGroupCreatedAt, UnverifiedEmployeeGroupUpdatedAt, UnverifiedEmployeeGroupName, UnverifiedEmployeeGroupPhoneNumber, UnverifiedEmployeeGroupPassword, UnverifiedEmployeeGroupProfilepicture:
		return true
	}
	return false
}

func (e UnverifiedEmployeeGroup) String() string {
	return string(e)
}

func (e *UnverifiedEmployeeGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnverifiedEmployeeGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnverifiedEmployeeGroup", str)
	}
	return nil
}

func (e UnverifiedEmployeeGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for UnverifiedEmployee a enum of all orderable entities
// can be used f.e.: queryUnverifiedEmployee
type UnverifiedEmployeeOrderable string

const (
	UnverifiedEmployeeOrderableID             UnverifiedEmployeeOrderable = "id"
	UnverifiedEmployeeOrderableName           UnverifiedEmployeeOrderable = "name"
	UnverifiedEmployeeOrderablePhoneNumber    UnverifiedEmployeeOrderable = "phone_number"
	UnverifiedEmployeeOrderablePassword       UnverifiedEmployeeOrderable = "password"
	UnverifiedEmployeeOrderableProfilepicture UnverifiedEmployeeOrderable = "profilepicture"
)

var AllUnverifiedEmployeeOrderable = []UnverifiedEmployeeOrderable{
	UnverifiedEmployeeOrderableID,
	UnverifiedEmployeeOrderableName,
	UnverifiedEmployeeOrderablePhoneNumber,
	UnverifiedEmployeeOrderablePassword,
	UnverifiedEmployeeOrderableProfilepicture,
}

func (e UnverifiedEmployeeOrderable) IsValid() bool {
	switch e {
	case UnverifiedEmployeeOrderableID, UnverifiedEmployeeOrderableName, UnverifiedEmployeeOrderablePhoneNumber, UnverifiedEmployeeOrderablePassword, UnverifiedEmployeeOrderableProfilepicture:
		return true
	}
	return false
}

func (e UnverifiedEmployeeOrderable) String() string {
	return string(e)
}

func (e *UnverifiedEmployeeOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnverifiedEmployeeOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnverifiedEmployeeOrderable", str)
	}
	return nil
}

func (e UnverifiedEmployeeOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  UnverifiedEmployer
// Can be used f.e.: by queryUnverifiedEmployer
type UnverifiedEmployerGroup string

const (
	UnverifiedEmployerGroupID          UnverifiedEmployerGroup = "id"
	UnverifiedEmployerGroupCreatedAt   UnverifiedEmployerGroup = "createdAt"
	UnverifiedEmployerGroupUpdatedAt   UnverifiedEmployerGroup = "updatedAt"
	UnverifiedEmployerGroupName        UnverifiedEmployerGroup = "name"
	UnverifiedEmployerGroupPhoneNumber UnverifiedEmployerGroup = "phone_number"
	UnverifiedEmployerGroupPassword    UnverifiedEmployerGroup = "password"
	UnverifiedEmployerGroupBadge       UnverifiedEmployerGroup = "badge"
	UnverifiedEmployerGroupWebsite     UnverifiedEmployerGroup = "Website"
)

var AllUnverifiedEmployerGroup = []UnverifiedEmployerGroup{
	UnverifiedEmployerGroupID,
	UnverifiedEmployerGroupCreatedAt,
	UnverifiedEmployerGroupUpdatedAt,
	UnverifiedEmployerGroupName,
	UnverifiedEmployerGroupPhoneNumber,
	UnverifiedEmployerGroupPassword,
	UnverifiedEmployerGroupBadge,
	UnverifiedEmployerGroupWebsite,
}

func (e UnverifiedEmployerGroup) IsValid() bool {
	switch e {
	case UnverifiedEmployerGroupID, UnverifiedEmployerGroupCreatedAt, UnverifiedEmployerGroupUpdatedAt, UnverifiedEmployerGroupName, UnverifiedEmployerGroupPhoneNumber, UnverifiedEmployerGroupPassword, UnverifiedEmployerGroupBadge, UnverifiedEmployerGroupWebsite:
		return true
	}
	return false
}

func (e UnverifiedEmployerGroup) String() string {
	return string(e)
}

func (e *UnverifiedEmployerGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnverifiedEmployerGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnverifiedEmployerGroup", str)
	}
	return nil
}

func (e UnverifiedEmployerGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for UnverifiedEmployer a enum of all orderable entities
// can be used f.e.: queryUnverifiedEmployer
type UnverifiedEmployerOrderable string

const (
	UnverifiedEmployerOrderableID          UnverifiedEmployerOrderable = "id"
	UnverifiedEmployerOrderableName        UnverifiedEmployerOrderable = "name"
	UnverifiedEmployerOrderablePhoneNumber UnverifiedEmployerOrderable = "phone_number"
	UnverifiedEmployerOrderablePassword    UnverifiedEmployerOrderable = "password"
	UnverifiedEmployerOrderableBadge       UnverifiedEmployerOrderable = "badge"
	UnverifiedEmployerOrderableWebsite     UnverifiedEmployerOrderable = "Website"
)

var AllUnverifiedEmployerOrderable = []UnverifiedEmployerOrderable{
	UnverifiedEmployerOrderableID,
	UnverifiedEmployerOrderableName,
	UnverifiedEmployerOrderablePhoneNumber,
	UnverifiedEmployerOrderablePassword,
	UnverifiedEmployerOrderableBadge,
	UnverifiedEmployerOrderableWebsite,
}

func (e UnverifiedEmployerOrderable) IsValid() bool {
	switch e {
	case UnverifiedEmployerOrderableID, UnverifiedEmployerOrderableName, UnverifiedEmployerOrderablePhoneNumber, UnverifiedEmployerOrderablePassword, UnverifiedEmployerOrderableBadge, UnverifiedEmployerOrderableWebsite:
		return true
	}
	return false
}

func (e UnverifiedEmployerOrderable) String() string {
	return string(e)
}

func (e *UnverifiedEmployerOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnverifiedEmployerOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnverifiedEmployerOrderable", str)
	}
	return nil
}

func (e UnverifiedEmployerOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
