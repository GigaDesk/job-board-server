// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/fasibio/autogql/runtimehelper"
)

// AddSchool result with filterable data and affected rows
type AddSchoolPayload struct {
	School   *SchoolQueryResult `json:"school"`
	Affected []*School          `json:"affected"`
}

// AddUnverifiedSchool result with filterable data and affected rows
type AddUnverifiedSchoolPayload struct {
	UnverifiedSchool *UnverifiedSchoolQueryResult `json:"unverifiedSchool"`
	Affected         []*UnverifiedSchool          `json:"affected"`
}

// Boolean Filter simple datatypes
type BooleanFilterInput struct {
	And     []*bool             `json:"and,omitempty"`
	Or      []*bool             `json:"or,omitempty"`
	Not     *BooleanFilterInput `json:"not,omitempty"`
	Is      *bool               `json:"is,omitempty"`
	Null    *bool               `json:"null,omitempty"`
	NotNull *bool               `json:"notNull,omitempty"`
}

// DeleteSchool result with filterable data and count of affected entries
type DeleteSchoolPayload struct {
	School *SchoolQueryResult `json:"school"`
	// Count of deleted School entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteUnverifiedSchool result with filterable data and count of affected entries
type DeleteUnverifiedSchoolPayload struct {
	UnverifiedSchool *UnverifiedSchoolQueryResult `json:"unverifiedSchool"`
	// Count of deleted UnverifiedSchool entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// Filter between start and end (start > value < end)
type FloatFilterBetween struct {
	Start float64 `json:"start"`
	End   float64 `json:"end"`
}

// Float Filter simple datatypes
type FloatFilterInput struct {
	And     []*float64          `json:"and,omitempty"`
	Or      []*float64          `json:"or,omitempty"`
	Not     *FloatFilterInput   `json:"not,omitempty"`
	Eq      *float64            `json:"eq,omitempty"`
	Ne      *float64            `json:"ne,omitempty"`
	Gt      *float64            `json:"gt,omitempty"`
	Gte     *float64            `json:"gte,omitempty"`
	Lt      *float64            `json:"lt,omitempty"`
	Lte     *float64            `json:"lte,omitempty"`
	Null    *bool               `json:"null,omitempty"`
	NotNull *bool               `json:"notNull,omitempty"`
	In      []*float64          `json:"in,omitempty"`
	NotIn   []*float64          `json:"notIn,omitempty"`
	Between *FloatFilterBetween `json:"between,omitempty"`
}

// ID Filter simple datatypes
type IDFilterInput struct {
	And     []*string      `json:"and,omitempty"`
	Or      []*string      `json:"or,omitempty"`
	Not     *IDFilterInput `json:"not,omitempty"`
	Eq      *string        `json:"eq,omitempty"`
	Ne      *string        `json:"ne,omitempty"`
	Null    *bool          `json:"null,omitempty"`
	NotNull *bool          `json:"notNull,omitempty"`
	In      []*string      `json:"in,omitempty"`
	Notin   []*string      `json:"notin,omitempty"`
}

// Filter between start and end (start > value < end)
type IntFilterBetween struct {
	Start int `json:"start"`
	End   int `json:"end"`
}

// Int Filter simple datatypes
type IntFilterInput struct {
	And     []*int            `json:"and,omitempty"`
	Or      []*int            `json:"or,omitempty"`
	Not     *IntFilterInput   `json:"not,omitempty"`
	Eq      *int              `json:"eq,omitempty"`
	Ne      *int              `json:"ne,omitempty"`
	Gt      *int              `json:"gt,omitempty"`
	Gte     *int              `json:"gte,omitempty"`
	Lt      *int              `json:"lt,omitempty"`
	Lte     *int              `json:"lte,omitempty"`
	Null    *bool             `json:"null,omitempty"`
	NotNull *bool             `json:"notNull,omitempty"`
	In      []*int            `json:"in,omitempty"`
	NotIn   []*int            `json:"notIn,omitempty"`
	Between *IntFilterBetween `json:"between,omitempty"`
}

type Mutation struct {
}

type NewSchool struct {
	Name        string  `json:"name"`
	PhoneNumber string  `json:"phone_number"`
	Password    string  `json:"password"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

type PhoneNumberExists struct {
	Verified   bool `json:"verified"`
	Unverified bool `json:"unverified"`
}

type Query struct {
}

type School struct {
	ID          int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt   time.Time                 `json:"createdAt"`
	UpdatedAt   time.Time                 `json:"updatedAt"`
	DeletedAt   *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Name        string                    `json:"name"`
	PhoneNumber string                    `json:"phone_number"`
	Password    string                    `json:"password"`
	Badge       *string                   `json:"badge,omitempty"`
	Website     *string                   `json:"Website,omitempty"`
}

// Filter input selection for School
// Can be used f.e.: by querySchool
type SchoolFiltersInput struct {
	ID          *IntFilterInput       `json:"id,omitempty"`
	CreatedAt   *TimeFilterInput      `json:"createdAt,omitempty"`
	UpdatedAt   *TimeFilterInput      `json:"updatedAt,omitempty"`
	Name        *StringFilterInput    `json:"name,omitempty"`
	PhoneNumber *StringFilterInput    `json:"phone_number,omitempty"`
	Password    *StringFilterInput    `json:"password,omitempty"`
	Badge       *StringFilterInput    `json:"badge,omitempty"`
	Website     *StringFilterInput    `json:"Website,omitempty"`
	And         []*SchoolFiltersInput `json:"and,omitempty"`
	Or          []*SchoolFiltersInput `json:"or,omitempty"`
	Not         *SchoolFiltersInput   `json:"not,omitempty"`
}

// School Input value to add new School
type SchoolInput struct {
	Name        string  `json:"name"`
	PhoneNumber string  `json:"phone_number"`
	Password    string  `json:"password"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

// Order School by asc or desc
type SchoolOrder struct {
	Asc  *SchoolOrderable `json:"asc,omitempty"`
	Desc *SchoolOrderable `json:"desc,omitempty"`
}

// School Patch value all values are optional to update School entities
type SchoolPatch struct {
	Name        *string `json:"name,omitempty"`
	PhoneNumber *string `json:"phone_number,omitempty"`
	Password    *string `json:"password,omitempty"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

// School result
type SchoolQueryResult struct {
	Data       []*School `json:"data"`
	Count      int       `json:"count"`
	TotalCount int       `json:"totalCount"`
}

type SendCodeStatus struct {
	PhoneNumber string `json:"phone_number"`
	Success     bool   `json:"success"`
}

// SoftDelete Filter simple datatypes
type SoftDeleteFilterInput struct {
	And     []*time.Time           `json:"and,omitempty"`
	Or      []*time.Time           `json:"or,omitempty"`
	Not     *SoftDeleteFilterInput `json:"not,omitempty"`
	Eq      *time.Time             `json:"eq,omitempty"`
	Ne      *time.Time             `json:"ne,omitempty"`
	Gt      *time.Time             `json:"gt,omitempty"`
	Gte     *time.Time             `json:"gte,omitempty"`
	Lt      *time.Time             `json:"lt,omitempty"`
	Lte     *time.Time             `json:"lte,omitempty"`
	Null    *bool                  `json:"null,omitempty"`
	NotNull *bool                  `json:"notNull,omitempty"`
	In      []*time.Time           `json:"in,omitempty"`
	NotIn   []*time.Time           `json:"notIn,omitempty"`
	Between *TimeFilterBetween     `json:"between,omitempty"`
}

type SQLCreateExtension struct {
	Value        bool     `json:"value"`
	DirectiveExt []string `json:"directiveExt,omitempty"`
}

type SQLMutationParams struct {
	Add          *SQLCreateExtension `json:"add,omitempty"`
	Update       *SQLCreateExtension `json:"update,omitempty"`
	Delete       *SQLCreateExtension `json:"delete,omitempty"`
	DirectiveExt []string            `json:"directiveExt,omitempty"`
}

type SQLQueryParams struct {
	Get          *SQLCreateExtension `json:"get,omitempty"`
	Query        *SQLCreateExtension `json:"query,omitempty"`
	DirectiveExt []string            `json:"directiveExt,omitempty"`
}

// String Filter simple datatypes
type StringFilterInput struct {
	And          []*string          `json:"and,omitempty"`
	Or           []*string          `json:"or,omitempty"`
	Not          *StringFilterInput `json:"not,omitempty"`
	Eq           *string            `json:"eq,omitempty"`
	Eqi          *string            `json:"eqi,omitempty"`
	Ne           *string            `json:"ne,omitempty"`
	StartsWith   *string            `json:"startsWith,omitempty"`
	EndsWith     *string            `json:"endsWith,omitempty"`
	Contains     *string            `json:"contains,omitempty"`
	NotContains  *string            `json:"notContains,omitempty"`
	Containsi    *string            `json:"containsi,omitempty"`
	NotContainsi *string            `json:"notContainsi,omitempty"`
	Null         *bool              `json:"null,omitempty"`
	NotNull      *bool              `json:"notNull,omitempty"`
	In           []*string          `json:"in,omitempty"`
	NotIn        []*string          `json:"notIn,omitempty"`
}

// Filter between start and end (start > value < end)
type TimeFilterBetween struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

// Time Filter simple datatypes
type TimeFilterInput struct {
	And     []*time.Time       `json:"and,omitempty"`
	Or      []*time.Time       `json:"or,omitempty"`
	Not     *TimeFilterInput   `json:"not,omitempty"`
	Eq      *time.Time         `json:"eq,omitempty"`
	Ne      *time.Time         `json:"ne,omitempty"`
	Gt      *time.Time         `json:"gt,omitempty"`
	Gte     *time.Time         `json:"gte,omitempty"`
	Lt      *time.Time         `json:"lt,omitempty"`
	Lte     *time.Time         `json:"lte,omitempty"`
	Null    *bool              `json:"null,omitempty"`
	NotNull *bool              `json:"notNull,omitempty"`
	In      []*time.Time       `json:"in,omitempty"`
	NotIn   []*time.Time       `json:"notIn,omitempty"`
	Between *TimeFilterBetween `json:"between,omitempty"`
}

type UnverifiedSchool struct {
	ID          int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt   time.Time                 `json:"createdAt"`
	UpdatedAt   time.Time                 `json:"updatedAt"`
	DeletedAt   *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Name        string                    `json:"name"`
	PhoneNumber string                    `json:"phone_number"`
	Password    string                    `json:"password"`
	Badge       *string                   `json:"badge,omitempty"`
	Website     *string                   `json:"Website,omitempty"`
}

// Filter input selection for UnverifiedSchool
// Can be used f.e.: by queryUnverifiedSchool
type UnverifiedSchoolFiltersInput struct {
	ID          *IntFilterInput                 `json:"id,omitempty"`
	CreatedAt   *TimeFilterInput                `json:"createdAt,omitempty"`
	UpdatedAt   *TimeFilterInput                `json:"updatedAt,omitempty"`
	Name        *StringFilterInput              `json:"name,omitempty"`
	PhoneNumber *StringFilterInput              `json:"phone_number,omitempty"`
	Password    *StringFilterInput              `json:"password,omitempty"`
	Badge       *StringFilterInput              `json:"badge,omitempty"`
	Website     *StringFilterInput              `json:"Website,omitempty"`
	And         []*UnverifiedSchoolFiltersInput `json:"and,omitempty"`
	Or          []*UnverifiedSchoolFiltersInput `json:"or,omitempty"`
	Not         *UnverifiedSchoolFiltersInput   `json:"not,omitempty"`
}

// UnverifiedSchool Input value to add new UnverifiedSchool
type UnverifiedSchoolInput struct {
	Name        string  `json:"name"`
	PhoneNumber string  `json:"phone_number"`
	Password    string  `json:"password"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

// Order UnverifiedSchool by asc or desc
type UnverifiedSchoolOrder struct {
	Asc  *UnverifiedSchoolOrderable `json:"asc,omitempty"`
	Desc *UnverifiedSchoolOrderable `json:"desc,omitempty"`
}

// UnverifiedSchool Patch value all values are optional to update UnverifiedSchool entities
type UnverifiedSchoolPatch struct {
	Name        *string `json:"name,omitempty"`
	PhoneNumber *string `json:"phone_number,omitempty"`
	Password    *string `json:"password,omitempty"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

// UnverifiedSchool result
type UnverifiedSchoolQueryResult struct {
	Data       []*UnverifiedSchool `json:"data"`
	Count      int                 `json:"count"`
	TotalCount int                 `json:"totalCount"`
}

// Update rules for School multiupdates simple possible by global filtervalue
type UpdateSchoolInput struct {
	Filter *SchoolFiltersInput `json:"filter"`
	Set    *SchoolPatch        `json:"set"`
}

// UpdateSchool result with filterable data and affected rows
type UpdateSchoolPayload struct {
	School *SchoolQueryResult `json:"school"`
	// Count of affected updates
	Count    int       `json:"count"`
	Affected []*School `json:"affected"`
}

// Update rules for UnverifiedSchool multiupdates simple possible by global filtervalue
type UpdateUnverifiedSchoolInput struct {
	Filter *UnverifiedSchoolFiltersInput `json:"filter"`
	Set    *UnverifiedSchoolPatch        `json:"set"`
}

// UpdateUnverifiedSchool result with filterable data and affected rows
type UpdateUnverifiedSchoolPayload struct {
	UnverifiedSchool *UnverifiedSchoolQueryResult `json:"unverifiedSchool"`
	// Count of affected updates
	Count    int                 `json:"count"`
	Affected []*UnverifiedSchool `json:"affected"`
}

type Verificationinfo struct {
	PhoneNumber string `json:"phone_number"`
	Otp         string `json:"otp"`
}

// Groupable data for  School
// Can be used f.e.: by querySchool
type SchoolGroup string

const (
	SchoolGroupID          SchoolGroup = "id"
	SchoolGroupCreatedAt   SchoolGroup = "createdAt"
	SchoolGroupUpdatedAt   SchoolGroup = "updatedAt"
	SchoolGroupName        SchoolGroup = "name"
	SchoolGroupPhoneNumber SchoolGroup = "phone_number"
	SchoolGroupPassword    SchoolGroup = "password"
	SchoolGroupBadge       SchoolGroup = "badge"
	SchoolGroupWebsite     SchoolGroup = "Website"
)

var AllSchoolGroup = []SchoolGroup{
	SchoolGroupID,
	SchoolGroupCreatedAt,
	SchoolGroupUpdatedAt,
	SchoolGroupName,
	SchoolGroupPhoneNumber,
	SchoolGroupPassword,
	SchoolGroupBadge,
	SchoolGroupWebsite,
}

func (e SchoolGroup) IsValid() bool {
	switch e {
	case SchoolGroupID, SchoolGroupCreatedAt, SchoolGroupUpdatedAt, SchoolGroupName, SchoolGroupPhoneNumber, SchoolGroupPassword, SchoolGroupBadge, SchoolGroupWebsite:
		return true
	}
	return false
}

func (e SchoolGroup) String() string {
	return string(e)
}

func (e *SchoolGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SchoolGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SchoolGroup", str)
	}
	return nil
}

func (e SchoolGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for School a enum of all orderable entities
// can be used f.e.: querySchool
type SchoolOrderable string

const (
	SchoolOrderableID          SchoolOrderable = "id"
	SchoolOrderableName        SchoolOrderable = "name"
	SchoolOrderablePhoneNumber SchoolOrderable = "phone_number"
	SchoolOrderablePassword    SchoolOrderable = "password"
	SchoolOrderableBadge       SchoolOrderable = "badge"
	SchoolOrderableWebsite     SchoolOrderable = "Website"
)

var AllSchoolOrderable = []SchoolOrderable{
	SchoolOrderableID,
	SchoolOrderableName,
	SchoolOrderablePhoneNumber,
	SchoolOrderablePassword,
	SchoolOrderableBadge,
	SchoolOrderableWebsite,
}

func (e SchoolOrderable) IsValid() bool {
	switch e {
	case SchoolOrderableID, SchoolOrderableName, SchoolOrderablePhoneNumber, SchoolOrderablePassword, SchoolOrderableBadge, SchoolOrderableWebsite:
		return true
	}
	return false
}

func (e SchoolOrderable) String() string {
	return string(e)
}

func (e *SchoolOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SchoolOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SchoolOrderable", str)
	}
	return nil
}

func (e SchoolOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  UnverifiedSchool
// Can be used f.e.: by queryUnverifiedSchool
type UnverifiedSchoolGroup string

const (
	UnverifiedSchoolGroupID          UnverifiedSchoolGroup = "id"
	UnverifiedSchoolGroupCreatedAt   UnverifiedSchoolGroup = "createdAt"
	UnverifiedSchoolGroupUpdatedAt   UnverifiedSchoolGroup = "updatedAt"
	UnverifiedSchoolGroupName        UnverifiedSchoolGroup = "name"
	UnverifiedSchoolGroupPhoneNumber UnverifiedSchoolGroup = "phone_number"
	UnverifiedSchoolGroupPassword    UnverifiedSchoolGroup = "password"
	UnverifiedSchoolGroupBadge       UnverifiedSchoolGroup = "badge"
	UnverifiedSchoolGroupWebsite     UnverifiedSchoolGroup = "Website"
)

var AllUnverifiedSchoolGroup = []UnverifiedSchoolGroup{
	UnverifiedSchoolGroupID,
	UnverifiedSchoolGroupCreatedAt,
	UnverifiedSchoolGroupUpdatedAt,
	UnverifiedSchoolGroupName,
	UnverifiedSchoolGroupPhoneNumber,
	UnverifiedSchoolGroupPassword,
	UnverifiedSchoolGroupBadge,
	UnverifiedSchoolGroupWebsite,
}

func (e UnverifiedSchoolGroup) IsValid() bool {
	switch e {
	case UnverifiedSchoolGroupID, UnverifiedSchoolGroupCreatedAt, UnverifiedSchoolGroupUpdatedAt, UnverifiedSchoolGroupName, UnverifiedSchoolGroupPhoneNumber, UnverifiedSchoolGroupPassword, UnverifiedSchoolGroupBadge, UnverifiedSchoolGroupWebsite:
		return true
	}
	return false
}

func (e UnverifiedSchoolGroup) String() string {
	return string(e)
}

func (e *UnverifiedSchoolGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnverifiedSchoolGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnverifiedSchoolGroup", str)
	}
	return nil
}

func (e UnverifiedSchoolGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for UnverifiedSchool a enum of all orderable entities
// can be used f.e.: queryUnverifiedSchool
type UnverifiedSchoolOrderable string

const (
	UnverifiedSchoolOrderableID          UnverifiedSchoolOrderable = "id"
	UnverifiedSchoolOrderableName        UnverifiedSchoolOrderable = "name"
	UnverifiedSchoolOrderablePhoneNumber UnverifiedSchoolOrderable = "phone_number"
	UnverifiedSchoolOrderablePassword    UnverifiedSchoolOrderable = "password"
	UnverifiedSchoolOrderableBadge       UnverifiedSchoolOrderable = "badge"
	UnverifiedSchoolOrderableWebsite     UnverifiedSchoolOrderable = "Website"
)

var AllUnverifiedSchoolOrderable = []UnverifiedSchoolOrderable{
	UnverifiedSchoolOrderableID,
	UnverifiedSchoolOrderableName,
	UnverifiedSchoolOrderablePhoneNumber,
	UnverifiedSchoolOrderablePassword,
	UnverifiedSchoolOrderableBadge,
	UnverifiedSchoolOrderableWebsite,
}

func (e UnverifiedSchoolOrderable) IsValid() bool {
	switch e {
	case UnverifiedSchoolOrderableID, UnverifiedSchoolOrderableName, UnverifiedSchoolOrderablePhoneNumber, UnverifiedSchoolOrderablePassword, UnverifiedSchoolOrderableBadge, UnverifiedSchoolOrderableWebsite:
		return true
	}
	return false
}

func (e UnverifiedSchoolOrderable) String() string {
	return string(e)
}

func (e *UnverifiedSchoolOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnverifiedSchoolOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnverifiedSchoolOrderable", str)
	}
	return nil
}

func (e UnverifiedSchoolOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
