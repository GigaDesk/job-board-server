// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/fasibio/autogql/runtimehelper"
)

// AddAdmin result with filterable data and affected rows
type AddAdminPayload struct {
	Admin    *AdminQueryResult `json:"admin"`
	Affected []*Admin          `json:"affected"`
}

// AddJob result with filterable data and affected rows
type AddJobPayload struct {
	Job      *JobQueryResult `json:"job"`
	Affected []*Job          `json:"affected"`
}

// AddSchool result with filterable data and affected rows
type AddSchoolPayload struct {
	School   *SchoolQueryResult `json:"school"`
	Affected []*School          `json:"affected"`
}

// AddStudent result with filterable data and affected rows
type AddStudentPayload struct {
	Student  *StudentQueryResult `json:"student"`
	Affected []*Student          `json:"affected"`
}

// AddUnverifiedAdmin result with filterable data and affected rows
type AddUnverifiedAdminPayload struct {
	UnverifiedAdmin *UnverifiedAdminQueryResult `json:"unverifiedAdmin"`
	Affected        []*UnverifiedAdmin          `json:"affected"`
}

// AddUnverifiedSchool result with filterable data and affected rows
type AddUnverifiedSchoolPayload struct {
	UnverifiedSchool *UnverifiedSchoolQueryResult `json:"unverifiedSchool"`
	Affected         []*UnverifiedSchool          `json:"affected"`
}

type Admin struct {
	ID          int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt   time.Time                 `json:"createdAt"`
	UpdatedAt   time.Time                 `json:"updatedAt"`
	DeletedAt   *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Name        string                    `json:"name"`
	PhoneNumber string                    `json:"phone_number"`
	Password    string                    `json:"password"`
}

// Filter input selection for Admin
// Can be used f.e.: by queryAdmin
type AdminFiltersInput struct {
	ID          *IntFilterInput      `json:"id,omitempty"`
	CreatedAt   *TimeFilterInput     `json:"createdAt,omitempty"`
	UpdatedAt   *TimeFilterInput     `json:"updatedAt,omitempty"`
	Name        *StringFilterInput   `json:"name,omitempty"`
	PhoneNumber *StringFilterInput   `json:"phone_number,omitempty"`
	Password    *StringFilterInput   `json:"password,omitempty"`
	And         []*AdminFiltersInput `json:"and,omitempty"`
	Or          []*AdminFiltersInput `json:"or,omitempty"`
	Not         *AdminFiltersInput   `json:"not,omitempty"`
}

// Admin Input value to add new Admin
type AdminInput struct {
	Name        string `json:"name"`
	PhoneNumber string `json:"phone_number"`
	Password    string `json:"password"`
}

type AdminLogin struct {
	PhoneNumber string `json:"phone_number"`
	Password    string `json:"password"`
}

// Order Admin by asc or desc
type AdminOrder struct {
	Asc  *AdminOrderable `json:"asc,omitempty"`
	Desc *AdminOrderable `json:"desc,omitempty"`
}

// Admin Patch value all values are optional to update Admin entities
type AdminPatch struct {
	Name        *string `json:"name,omitempty"`
	PhoneNumber *string `json:"phone_number,omitempty"`
	Password    *string `json:"password,omitempty"`
}

type AdminProfile struct {
	ID          int       `json:"id"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
	Name        string    `json:"name"`
	PhoneNumber string    `json:"phone_number"`
}

// Admin result
type AdminQueryResult struct {
	Data       []*Admin `json:"data"`
	Count      int      `json:"count"`
	TotalCount int      `json:"totalCount"`
}

// Boolean Filter simple datatypes
type BooleanFilterInput struct {
	And     []*bool             `json:"and,omitempty"`
	Or      []*bool             `json:"or,omitempty"`
	Not     *BooleanFilterInput `json:"not,omitempty"`
	Is      *bool               `json:"is,omitempty"`
	Null    *bool               `json:"null,omitempty"`
	NotNull *bool               `json:"notNull,omitempty"`
}

// DeleteAdmin result with filterable data and count of affected entries
type DeleteAdminPayload struct {
	Admin *AdminQueryResult `json:"admin"`
	// Count of deleted Admin entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteJob result with filterable data and count of affected entries
type DeleteJobPayload struct {
	Job *JobQueryResult `json:"job"`
	// Count of deleted Job entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteSchool result with filterable data and count of affected entries
type DeleteSchoolPayload struct {
	School *SchoolQueryResult `json:"school"`
	// Count of deleted School entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteStudent result with filterable data and count of affected entries
type DeleteStudentPayload struct {
	Student *StudentQueryResult `json:"student"`
	// Count of deleted Student entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteUnverifiedAdmin result with filterable data and count of affected entries
type DeleteUnverifiedAdminPayload struct {
	UnverifiedAdmin *UnverifiedAdminQueryResult `json:"unverifiedAdmin"`
	// Count of deleted UnverifiedAdmin entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteUnverifiedSchool result with filterable data and count of affected entries
type DeleteUnverifiedSchoolPayload struct {
	UnverifiedSchool *UnverifiedSchoolQueryResult `json:"unverifiedSchool"`
	// Count of deleted UnverifiedSchool entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

type Dummy struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

// Filter between start and end (start > value < end)
type FloatFilterBetween struct {
	Start float64 `json:"start"`
	End   float64 `json:"end"`
}

// Float Filter simple datatypes
type FloatFilterInput struct {
	And     []*float64          `json:"and,omitempty"`
	Or      []*float64          `json:"or,omitempty"`
	Not     *FloatFilterInput   `json:"not,omitempty"`
	Eq      *float64            `json:"eq,omitempty"`
	Ne      *float64            `json:"ne,omitempty"`
	Gt      *float64            `json:"gt,omitempty"`
	Gte     *float64            `json:"gte,omitempty"`
	Lt      *float64            `json:"lt,omitempty"`
	Lte     *float64            `json:"lte,omitempty"`
	Null    *bool               `json:"null,omitempty"`
	NotNull *bool               `json:"notNull,omitempty"`
	In      []*float64          `json:"in,omitempty"`
	NotIn   []*float64          `json:"notIn,omitempty"`
	Between *FloatFilterBetween `json:"between,omitempty"`
}

// ID Filter simple datatypes
type IDFilterInput struct {
	And     []*string      `json:"and,omitempty"`
	Or      []*string      `json:"or,omitempty"`
	Not     *IDFilterInput `json:"not,omitempty"`
	Eq      *string        `json:"eq,omitempty"`
	Ne      *string        `json:"ne,omitempty"`
	Null    *bool          `json:"null,omitempty"`
	NotNull *bool          `json:"notNull,omitempty"`
	In      []*string      `json:"in,omitempty"`
	Notin   []*string      `json:"notin,omitempty"`
}

// Filter between start and end (start > value < end)
type IntFilterBetween struct {
	Start int `json:"start"`
	End   int `json:"end"`
}

// Int Filter simple datatypes
type IntFilterInput struct {
	And     []*int            `json:"and,omitempty"`
	Or      []*int            `json:"or,omitempty"`
	Not     *IntFilterInput   `json:"not,omitempty"`
	Eq      *int              `json:"eq,omitempty"`
	Ne      *int              `json:"ne,omitempty"`
	Gt      *int              `json:"gt,omitempty"`
	Gte     *int              `json:"gte,omitempty"`
	Lt      *int              `json:"lt,omitempty"`
	Lte     *int              `json:"lte,omitempty"`
	Null    *bool             `json:"null,omitempty"`
	NotNull *bool             `json:"notNull,omitempty"`
	In      []*int            `json:"in,omitempty"`
	NotIn   []*int            `json:"notIn,omitempty"`
	Between *IntFilterBetween `json:"between,omitempty"`
}

type Job struct {
	ID             int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt      time.Time                 `json:"createdAt"`
	UpdatedAt      time.Time                 `json:"updatedAt"`
	DeletedAt      *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Title          string                    `json:"title"`
	Industry       *string                   `json:"industry,omitempty"`
	Description    string                    `json:"description"`
	Level          *string                   `json:"level,omitempty"`
	Location       *string                   `json:"location,omitempty"`
	Deadline       *time.Time                `json:"deadline,omitempty"`
	EducationLevel *string                   `json:"educationLevel,omitempty"`
	Experience     *int                      `json:"experience,omitempty"`
	MinSalary      *int                      `json:"minSalary,omitempty"`
	MaxSalary      *int                      `json:"maxSalary,omitempty"`
	Requirements   *string                   `json:"requirements,omitempty"`
}

// Filter input selection for Job
// Can be used f.e.: by queryJob
type JobFiltersInput struct {
	ID             *IntFilterInput    `json:"id,omitempty"`
	CreatedAt      *TimeFilterInput   `json:"createdAt,omitempty"`
	UpdatedAt      *TimeFilterInput   `json:"updatedAt,omitempty"`
	Title          *StringFilterInput `json:"title,omitempty"`
	Industry       *StringFilterInput `json:"industry,omitempty"`
	Description    *StringFilterInput `json:"description,omitempty"`
	Level          *StringFilterInput `json:"level,omitempty"`
	Location       *StringFilterInput `json:"location,omitempty"`
	Deadline       *TimeFilterInput   `json:"deadline,omitempty"`
	EducationLevel *StringFilterInput `json:"educationLevel,omitempty"`
	Experience     *IntFilterInput    `json:"experience,omitempty"`
	MinSalary      *IntFilterInput    `json:"minSalary,omitempty"`
	MaxSalary      *IntFilterInput    `json:"maxSalary,omitempty"`
	Requirements   *StringFilterInput `json:"requirements,omitempty"`
	And            []*JobFiltersInput `json:"and,omitempty"`
	Or             []*JobFiltersInput `json:"or,omitempty"`
	Not            *JobFiltersInput   `json:"not,omitempty"`
}

// Job Input value to add new Job
type JobInput struct {
	Title          string     `json:"title"`
	Industry       *string    `json:"industry,omitempty"`
	Description    string     `json:"description"`
	Level          *string    `json:"level,omitempty"`
	Location       *string    `json:"location,omitempty"`
	Deadline       *time.Time `json:"deadline,omitempty"`
	EducationLevel *string    `json:"educationLevel,omitempty"`
	Experience     *int       `json:"experience,omitempty"`
	MinSalary      *int       `json:"minSalary,omitempty"`
	MaxSalary      *int       `json:"maxSalary,omitempty"`
	Requirements   *string    `json:"requirements,omitempty"`
}

// Order Job by asc or desc
type JobOrder struct {
	Asc  *JobOrderable `json:"asc,omitempty"`
	Desc *JobOrderable `json:"desc,omitempty"`
}

// Job Patch value all values are optional to update Job entities
type JobPatch struct {
	Title          *string    `json:"title,omitempty"`
	Industry       *string    `json:"industry,omitempty"`
	Description    *string    `json:"description,omitempty"`
	Level          *string    `json:"level,omitempty"`
	Location       *string    `json:"location,omitempty"`
	Deadline       *time.Time `json:"deadline,omitempty"`
	EducationLevel *string    `json:"educationLevel,omitempty"`
	Experience     *int       `json:"experience,omitempty"`
	MinSalary      *int       `json:"minSalary,omitempty"`
	MaxSalary      *int       `json:"maxSalary,omitempty"`
	Requirements   *string    `json:"requirements,omitempty"`
}

type JobProfile struct {
	ID             int                       `json:"id"`
	CreatedAt      time.Time                 `json:"createdAt"`
	UpdatedAt      time.Time                 `json:"updatedAt"`
	DeletedAt      *runtimehelper.SoftDelete `json:"deletedAt,omitempty"`
	Title          string                    `json:"title"`
	Industry       *string                   `json:"industry,omitempty"`
	Description    string                    `json:"description"`
	Level          *string                   `json:"level,omitempty"`
	Location       *string                   `json:"location,omitempty"`
	Deadline       *time.Time                `json:"deadline,omitempty"`
	EducationLevel *string                   `json:"educationLevel,omitempty"`
	Experience     *int                      `json:"experience,omitempty"`
	MinSalary      *int                      `json:"minSalary,omitempty"`
	MaxSalary      *int                      `json:"maxSalary,omitempty"`
	Requirements   []string                  `json:"requirements,omitempty"`
}

// Job result
type JobQueryResult struct {
	Data       []*Job `json:"data"`
	Count      int    `json:"count"`
	TotalCount int    `json:"totalCount"`
}

type Mutation struct {
}

type NewAdmin struct {
	Name        string `json:"name"`
	PhoneNumber string `json:"phone_number"`
	Password    string `json:"password"`
}

type NewJob struct {
	Title          string     `json:"title"`
	Description    string     `json:"description"`
	Industry       *string    `json:"industry,omitempty"`
	Level          *string    `json:"level,omitempty"`
	Location       *string    `json:"location,omitempty"`
	Deadline       *time.Time `json:"deadline,omitempty"`
	EducationLevel *string    `json:"educationLevel,omitempty"`
	Experience     *int       `json:"experience,omitempty"`
	MinSalary      *int       `json:"minSalary,omitempty"`
	MaxSalary      *int       `json:"maxSalary,omitempty"`
	Requirements   []string   `json:"requirements,omitempty"`
}

type NewSchool struct {
	Name        string  `json:"name"`
	PhoneNumber string  `json:"phone_number"`
	Password    string  `json:"password"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

type NewStudent struct {
	RegistrationNumber string     `json:"registration_number"`
	Name               string     `json:"name"`
	PhoneNumber        string     `json:"phone_number"`
	Password           string     `json:"password"`
	DateOfAdmission    *time.Time `json:"date_of_admission,omitempty"`
	DateOfBirth        *time.Time `json:"date_of_birth,omitempty"`
	ProfilePicture     *string    `json:"profile_picture,omitempty"`
}

type PhoneNumberExists struct {
	Verified   bool `json:"verified"`
	Unverified bool `json:"unverified"`
}

type Query struct {
}

type RefreshTokenInput struct {
	Token string `json:"Token"`
}

type School struct {
	ID          int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt   time.Time                 `json:"createdAt"`
	UpdatedAt   time.Time                 `json:"updatedAt"`
	DeletedAt   *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Name        string                    `json:"name"`
	PhoneNumber string                    `json:"phone_number"`
	Password    string                    `json:"password"`
	Badge       *string                   `json:"badge,omitempty"`
	Website     *string                   `json:"Website,omitempty"`
}

// Filter input selection for School
// Can be used f.e.: by querySchool
type SchoolFiltersInput struct {
	ID          *IntFilterInput       `json:"id,omitempty"`
	CreatedAt   *TimeFilterInput      `json:"createdAt,omitempty"`
	UpdatedAt   *TimeFilterInput      `json:"updatedAt,omitempty"`
	Name        *StringFilterInput    `json:"name,omitempty"`
	PhoneNumber *StringFilterInput    `json:"phone_number,omitempty"`
	Password    *StringFilterInput    `json:"password,omitempty"`
	Badge       *StringFilterInput    `json:"badge,omitempty"`
	Website     *StringFilterInput    `json:"Website,omitempty"`
	And         []*SchoolFiltersInput `json:"and,omitempty"`
	Or          []*SchoolFiltersInput `json:"or,omitempty"`
	Not         *SchoolFiltersInput   `json:"not,omitempty"`
}

// School Input value to add new School
type SchoolInput struct {
	Name        string  `json:"name"`
	PhoneNumber string  `json:"phone_number"`
	Password    string  `json:"password"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

type SchoolLogin struct {
	PhoneNumber string `json:"phone_number"`
	Password    string `json:"password"`
}

// Order School by asc or desc
type SchoolOrder struct {
	Asc  *SchoolOrderable `json:"asc,omitempty"`
	Desc *SchoolOrderable `json:"desc,omitempty"`
}

// School Patch value all values are optional to update School entities
type SchoolPatch struct {
	Name        *string `json:"name,omitempty"`
	PhoneNumber *string `json:"phone_number,omitempty"`
	Password    *string `json:"password,omitempty"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

type SchoolProfile struct {
	ID          int               `json:"id"`
	CreatedAt   time.Time         `json:"createdAt"`
	UpdatedAt   time.Time         `json:"updatedAt"`
	Name        string            `json:"name"`
	PhoneNumber string            `json:"phone_number"`
	Badge       *string           `json:"badge,omitempty"`
	Website     *string           `json:"Website,omitempty"`
	Students    []*StudentProfile `json:"students,omitempty"`
}

// School result
type SchoolQueryResult struct {
	Data       []*School `json:"data"`
	Count      int       `json:"count"`
	TotalCount int       `json:"totalCount"`
}

type SendCodeStatus struct {
	PhoneNumber string `json:"phone_number"`
	Success     bool   `json:"success"`
}

// SoftDelete Filter simple datatypes
type SoftDeleteFilterInput struct {
	And     []*time.Time           `json:"and,omitempty"`
	Or      []*time.Time           `json:"or,omitempty"`
	Not     *SoftDeleteFilterInput `json:"not,omitempty"`
	Eq      *time.Time             `json:"eq,omitempty"`
	Ne      *time.Time             `json:"ne,omitempty"`
	Gt      *time.Time             `json:"gt,omitempty"`
	Gte     *time.Time             `json:"gte,omitempty"`
	Lt      *time.Time             `json:"lt,omitempty"`
	Lte     *time.Time             `json:"lte,omitempty"`
	Null    *bool                  `json:"null,omitempty"`
	NotNull *bool                  `json:"notNull,omitempty"`
	In      []*time.Time           `json:"in,omitempty"`
	NotIn   []*time.Time           `json:"notIn,omitempty"`
	Between *TimeFilterBetween     `json:"between,omitempty"`
}

type SQLCreateExtension struct {
	Value        bool     `json:"value"`
	DirectiveExt []string `json:"directiveExt,omitempty"`
}

type SQLMutationParams struct {
	Add          *SQLCreateExtension `json:"add,omitempty"`
	Update       *SQLCreateExtension `json:"update,omitempty"`
	Delete       *SQLCreateExtension `json:"delete,omitempty"`
	DirectiveExt []string            `json:"directiveExt,omitempty"`
}

type SQLQueryParams struct {
	Get          *SQLCreateExtension `json:"get,omitempty"`
	Query        *SQLCreateExtension `json:"query,omitempty"`
	DirectiveExt []string            `json:"directiveExt,omitempty"`
}

// String Filter simple datatypes
type StringFilterInput struct {
	And          []*string          `json:"and,omitempty"`
	Or           []*string          `json:"or,omitempty"`
	Not          *StringFilterInput `json:"not,omitempty"`
	Eq           *string            `json:"eq,omitempty"`
	Eqi          *string            `json:"eqi,omitempty"`
	Ne           *string            `json:"ne,omitempty"`
	StartsWith   *string            `json:"startsWith,omitempty"`
	EndsWith     *string            `json:"endsWith,omitempty"`
	Contains     *string            `json:"contains,omitempty"`
	NotContains  *string            `json:"notContains,omitempty"`
	Containsi    *string            `json:"containsi,omitempty"`
	NotContainsi *string            `json:"notContainsi,omitempty"`
	Null         *bool              `json:"null,omitempty"`
	NotNull      *bool              `json:"notNull,omitempty"`
	In           []*string          `json:"in,omitempty"`
	NotIn        []*string          `json:"notIn,omitempty"`
}

type Student struct {
	ID                 int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt          time.Time                 `json:"createdAt"`
	UpdatedAt          time.Time                 `json:"updatedAt"`
	DeletedAt          *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	RegistrationNumber string                    `json:"registration_number"`
	Name               string                    `json:"name"`
	PhoneNumber        string                    `json:"phone_number"`
	Password           string                    `json:"password"`
	DateOfAdmission    *time.Time                `json:"date_of_admission,omitempty"`
	DateOfBirth        *time.Time                `json:"date_of_birth,omitempty"`
	ProfilePicture     *string                   `json:"profile_picture,omitempty"`
}

// Filter input selection for Student
// Can be used f.e.: by queryStudent
type StudentFiltersInput struct {
	ID                 *IntFilterInput        `json:"id,omitempty"`
	CreatedAt          *TimeFilterInput       `json:"createdAt,omitempty"`
	UpdatedAt          *TimeFilterInput       `json:"updatedAt,omitempty"`
	RegistrationNumber *StringFilterInput     `json:"registration_number,omitempty"`
	Name               *StringFilterInput     `json:"name,omitempty"`
	PhoneNumber        *StringFilterInput     `json:"phone_number,omitempty"`
	Password           *StringFilterInput     `json:"password,omitempty"`
	DateOfAdmission    *TimeFilterInput       `json:"date_of_admission,omitempty"`
	DateOfBirth        *TimeFilterInput       `json:"date_of_birth,omitempty"`
	ProfilePicture     *StringFilterInput     `json:"profile_picture,omitempty"`
	And                []*StudentFiltersInput `json:"and,omitempty"`
	Or                 []*StudentFiltersInput `json:"or,omitempty"`
	Not                *StudentFiltersInput   `json:"not,omitempty"`
}

// Student Input value to add new Student
type StudentInput struct {
	RegistrationNumber string     `json:"registration_number"`
	Name               string     `json:"name"`
	PhoneNumber        string     `json:"phone_number"`
	Password           string     `json:"password"`
	DateOfAdmission    *time.Time `json:"date_of_admission,omitempty"`
	DateOfBirth        *time.Time `json:"date_of_birth,omitempty"`
	ProfilePicture     *string    `json:"profile_picture,omitempty"`
}

type StudentLogin struct {
	Schoolid           int    `json:"schoolid"`
	RegistrationNumber string `json:"registration_number"`
	Password           string `json:"password"`
}

// Order Student by asc or desc
type StudentOrder struct {
	Asc  *StudentOrderable `json:"asc,omitempty"`
	Desc *StudentOrderable `json:"desc,omitempty"`
}

// Student Patch value all values are optional to update Student entities
type StudentPatch struct {
	RegistrationNumber *string    `json:"registration_number,omitempty"`
	Name               *string    `json:"name,omitempty"`
	PhoneNumber        *string    `json:"phone_number,omitempty"`
	Password           *string    `json:"password,omitempty"`
	DateOfAdmission    *time.Time `json:"date_of_admission,omitempty"`
	DateOfBirth        *time.Time `json:"date_of_birth,omitempty"`
	ProfilePicture     *string    `json:"profile_picture,omitempty"`
}

type StudentProfile struct {
	ID                 int                       `json:"id"`
	CreatedAt          time.Time                 `json:"createdAt"`
	UpdatedAt          time.Time                 `json:"updatedAt"`
	DeletedAt          *runtimehelper.SoftDelete `json:"deletedAt,omitempty"`
	RegistrationNumber string                    `json:"registration_number"`
	Name               string                    `json:"name"`
	PhoneNumber        string                    `json:"phone_number"`
	Password           string                    `json:"password"`
	DateOfAdmission    *time.Time                `json:"date_of_admission,omitempty"`
	DateOfBirth        *time.Time                `json:"date_of_birth,omitempty"`
	ProfilePicture     *string                   `json:"profile_picture,omitempty"`
	School             *SchoolProfile            `json:"school"`
}

// Student result
type StudentQueryResult struct {
	Data       []*Student `json:"data"`
	Count      int        `json:"count"`
	TotalCount int        `json:"totalCount"`
}

// Filter between start and end (start > value < end)
type TimeFilterBetween struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

// Time Filter simple datatypes
type TimeFilterInput struct {
	And     []*time.Time       `json:"and,omitempty"`
	Or      []*time.Time       `json:"or,omitempty"`
	Not     *TimeFilterInput   `json:"not,omitempty"`
	Eq      *time.Time         `json:"eq,omitempty"`
	Ne      *time.Time         `json:"ne,omitempty"`
	Gt      *time.Time         `json:"gt,omitempty"`
	Gte     *time.Time         `json:"gte,omitempty"`
	Lt      *time.Time         `json:"lt,omitempty"`
	Lte     *time.Time         `json:"lte,omitempty"`
	Null    *bool              `json:"null,omitempty"`
	NotNull *bool              `json:"notNull,omitempty"`
	In      []*time.Time       `json:"in,omitempty"`
	NotIn   []*time.Time       `json:"notIn,omitempty"`
	Between *TimeFilterBetween `json:"between,omitempty"`
}

type UnverifiedAdmin struct {
	ID          int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt   time.Time                 `json:"createdAt"`
	UpdatedAt   time.Time                 `json:"updatedAt"`
	DeletedAt   *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Name        string                    `json:"name"`
	PhoneNumber string                    `json:"phone_number"`
	Password    string                    `json:"password"`
}

// Filter input selection for UnverifiedAdmin
// Can be used f.e.: by queryUnverifiedAdmin
type UnverifiedAdminFiltersInput struct {
	ID          *IntFilterInput                `json:"id,omitempty"`
	CreatedAt   *TimeFilterInput               `json:"createdAt,omitempty"`
	UpdatedAt   *TimeFilterInput               `json:"updatedAt,omitempty"`
	Name        *StringFilterInput             `json:"name,omitempty"`
	PhoneNumber *StringFilterInput             `json:"phone_number,omitempty"`
	Password    *StringFilterInput             `json:"password,omitempty"`
	And         []*UnverifiedAdminFiltersInput `json:"and,omitempty"`
	Or          []*UnverifiedAdminFiltersInput `json:"or,omitempty"`
	Not         *UnverifiedAdminFiltersInput   `json:"not,omitempty"`
}

// UnverifiedAdmin Input value to add new UnverifiedAdmin
type UnverifiedAdminInput struct {
	Name        string `json:"name"`
	PhoneNumber string `json:"phone_number"`
	Password    string `json:"password"`
}

// Order UnverifiedAdmin by asc or desc
type UnverifiedAdminOrder struct {
	Asc  *UnverifiedAdminOrderable `json:"asc,omitempty"`
	Desc *UnverifiedAdminOrderable `json:"desc,omitempty"`
}

// UnverifiedAdmin Patch value all values are optional to update UnverifiedAdmin entities
type UnverifiedAdminPatch struct {
	Name        *string `json:"name,omitempty"`
	PhoneNumber *string `json:"phone_number,omitempty"`
	Password    *string `json:"password,omitempty"`
}

// UnverifiedAdmin result
type UnverifiedAdminQueryResult struct {
	Data       []*UnverifiedAdmin `json:"data"`
	Count      int                `json:"count"`
	TotalCount int                `json:"totalCount"`
}

type UnverifiedSchool struct {
	ID          int                       `json:"id" gorm:"primaryKey;autoIncrement;"`
	CreatedAt   time.Time                 `json:"createdAt"`
	UpdatedAt   time.Time                 `json:"updatedAt"`
	DeletedAt   *runtimehelper.SoftDelete `json:"deletedAt,omitempty" gorm:"index;"`
	Name        string                    `json:"name"`
	PhoneNumber string                    `json:"phone_number"`
	Password    string                    `json:"password"`
	Badge       *string                   `json:"badge,omitempty"`
	Website     *string                   `json:"Website,omitempty"`
}

// Filter input selection for UnverifiedSchool
// Can be used f.e.: by queryUnverifiedSchool
type UnverifiedSchoolFiltersInput struct {
	ID          *IntFilterInput                 `json:"id,omitempty"`
	CreatedAt   *TimeFilterInput                `json:"createdAt,omitempty"`
	UpdatedAt   *TimeFilterInput                `json:"updatedAt,omitempty"`
	Name        *StringFilterInput              `json:"name,omitempty"`
	PhoneNumber *StringFilterInput              `json:"phone_number,omitempty"`
	Password    *StringFilterInput              `json:"password,omitempty"`
	Badge       *StringFilterInput              `json:"badge,omitempty"`
	Website     *StringFilterInput              `json:"Website,omitempty"`
	And         []*UnverifiedSchoolFiltersInput `json:"and,omitempty"`
	Or          []*UnverifiedSchoolFiltersInput `json:"or,omitempty"`
	Not         *UnverifiedSchoolFiltersInput   `json:"not,omitempty"`
}

// UnverifiedSchool Input value to add new UnverifiedSchool
type UnverifiedSchoolInput struct {
	Name        string  `json:"name"`
	PhoneNumber string  `json:"phone_number"`
	Password    string  `json:"password"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

// Order UnverifiedSchool by asc or desc
type UnverifiedSchoolOrder struct {
	Asc  *UnverifiedSchoolOrderable `json:"asc,omitempty"`
	Desc *UnverifiedSchoolOrderable `json:"desc,omitempty"`
}

// UnverifiedSchool Patch value all values are optional to update UnverifiedSchool entities
type UnverifiedSchoolPatch struct {
	Name        *string `json:"name,omitempty"`
	PhoneNumber *string `json:"phone_number,omitempty"`
	Password    *string `json:"password,omitempty"`
	Badge       *string `json:"badge,omitempty"`
	Website     *string `json:"Website,omitempty"`
}

// UnverifiedSchool result
type UnverifiedSchoolQueryResult struct {
	Data       []*UnverifiedSchool `json:"data"`
	Count      int                 `json:"count"`
	TotalCount int                 `json:"totalCount"`
}

// Update rules for Admin multiupdates simple possible by global filtervalue
type UpdateAdminInput struct {
	Filter *AdminFiltersInput `json:"filter"`
	Set    *AdminPatch        `json:"set"`
}

// UpdateAdmin result with filterable data and affected rows
type UpdateAdminPayload struct {
	Admin *AdminQueryResult `json:"admin"`
	// Count of affected updates
	Count    int      `json:"count"`
	Affected []*Admin `json:"affected"`
}

// Update rules for Job multiupdates simple possible by global filtervalue
type UpdateJobInput struct {
	Filter *JobFiltersInput `json:"filter"`
	Set    *JobPatch        `json:"set"`
}

// UpdateJob result with filterable data and affected rows
type UpdateJobPayload struct {
	Job *JobQueryResult `json:"job"`
	// Count of affected updates
	Count    int    `json:"count"`
	Affected []*Job `json:"affected"`
}

// Update rules for School multiupdates simple possible by global filtervalue
type UpdateSchoolInput struct {
	Filter *SchoolFiltersInput `json:"filter"`
	Set    *SchoolPatch        `json:"set"`
}

// UpdateSchool result with filterable data and affected rows
type UpdateSchoolPayload struct {
	School *SchoolQueryResult `json:"school"`
	// Count of affected updates
	Count    int       `json:"count"`
	Affected []*School `json:"affected"`
}

// Update rules for Student multiupdates simple possible by global filtervalue
type UpdateStudentInput struct {
	Filter *StudentFiltersInput `json:"filter"`
	Set    *StudentPatch        `json:"set"`
}

// UpdateStudent result with filterable data and affected rows
type UpdateStudentPayload struct {
	Student *StudentQueryResult `json:"student"`
	// Count of affected updates
	Count    int        `json:"count"`
	Affected []*Student `json:"affected"`
}

// Update rules for UnverifiedAdmin multiupdates simple possible by global filtervalue
type UpdateUnverifiedAdminInput struct {
	Filter *UnverifiedAdminFiltersInput `json:"filter"`
	Set    *UnverifiedAdminPatch        `json:"set"`
}

// UpdateUnverifiedAdmin result with filterable data and affected rows
type UpdateUnverifiedAdminPayload struct {
	UnverifiedAdmin *UnverifiedAdminQueryResult `json:"unverifiedAdmin"`
	// Count of affected updates
	Count    int                `json:"count"`
	Affected []*UnverifiedAdmin `json:"affected"`
}

// Update rules for UnverifiedSchool multiupdates simple possible by global filtervalue
type UpdateUnverifiedSchoolInput struct {
	Filter *UnverifiedSchoolFiltersInput `json:"filter"`
	Set    *UnverifiedSchoolPatch        `json:"set"`
}

// UpdateUnverifiedSchool result with filterable data and affected rows
type UpdateUnverifiedSchoolPayload struct {
	UnverifiedSchool *UnverifiedSchoolQueryResult `json:"unverifiedSchool"`
	// Count of affected updates
	Count    int                 `json:"count"`
	Affected []*UnverifiedSchool `json:"affected"`
}

type Verificationinfo struct {
	PhoneNumber string `json:"phone_number"`
	Otp         string `json:"otp"`
}

// Groupable data for  Admin
// Can be used f.e.: by queryAdmin
type AdminGroup string

const (
	AdminGroupID          AdminGroup = "id"
	AdminGroupCreatedAt   AdminGroup = "createdAt"
	AdminGroupUpdatedAt   AdminGroup = "updatedAt"
	AdminGroupName        AdminGroup = "name"
	AdminGroupPhoneNumber AdminGroup = "phone_number"
	AdminGroupPassword    AdminGroup = "password"
)

var AllAdminGroup = []AdminGroup{
	AdminGroupID,
	AdminGroupCreatedAt,
	AdminGroupUpdatedAt,
	AdminGroupName,
	AdminGroupPhoneNumber,
	AdminGroupPassword,
}

func (e AdminGroup) IsValid() bool {
	switch e {
	case AdminGroupID, AdminGroupCreatedAt, AdminGroupUpdatedAt, AdminGroupName, AdminGroupPhoneNumber, AdminGroupPassword:
		return true
	}
	return false
}

func (e AdminGroup) String() string {
	return string(e)
}

func (e *AdminGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdminGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AdminGroup", str)
	}
	return nil
}

func (e AdminGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for Admin a enum of all orderable entities
// can be used f.e.: queryAdmin
type AdminOrderable string

const (
	AdminOrderableID          AdminOrderable = "id"
	AdminOrderableName        AdminOrderable = "name"
	AdminOrderablePhoneNumber AdminOrderable = "phone_number"
	AdminOrderablePassword    AdminOrderable = "password"
)

var AllAdminOrderable = []AdminOrderable{
	AdminOrderableID,
	AdminOrderableName,
	AdminOrderablePhoneNumber,
	AdminOrderablePassword,
}

func (e AdminOrderable) IsValid() bool {
	switch e {
	case AdminOrderableID, AdminOrderableName, AdminOrderablePhoneNumber, AdminOrderablePassword:
		return true
	}
	return false
}

func (e AdminOrderable) String() string {
	return string(e)
}

func (e *AdminOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdminOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AdminOrderable", str)
	}
	return nil
}

func (e AdminOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  Job
// Can be used f.e.: by queryJob
type JobGroup string

const (
	JobGroupID             JobGroup = "id"
	JobGroupCreatedAt      JobGroup = "createdAt"
	JobGroupUpdatedAt      JobGroup = "updatedAt"
	JobGroupTitle          JobGroup = "title"
	JobGroupIndustry       JobGroup = "industry"
	JobGroupDescription    JobGroup = "description"
	JobGroupLevel          JobGroup = "level"
	JobGroupLocation       JobGroup = "location"
	JobGroupDeadline       JobGroup = "deadline"
	JobGroupEducationLevel JobGroup = "educationLevel"
	JobGroupExperience     JobGroup = "experience"
	JobGroupMinSalary      JobGroup = "minSalary"
	JobGroupMaxSalary      JobGroup = "maxSalary"
	JobGroupRequirements   JobGroup = "requirements"
)

var AllJobGroup = []JobGroup{
	JobGroupID,
	JobGroupCreatedAt,
	JobGroupUpdatedAt,
	JobGroupTitle,
	JobGroupIndustry,
	JobGroupDescription,
	JobGroupLevel,
	JobGroupLocation,
	JobGroupDeadline,
	JobGroupEducationLevel,
	JobGroupExperience,
	JobGroupMinSalary,
	JobGroupMaxSalary,
	JobGroupRequirements,
}

func (e JobGroup) IsValid() bool {
	switch e {
	case JobGroupID, JobGroupCreatedAt, JobGroupUpdatedAt, JobGroupTitle, JobGroupIndustry, JobGroupDescription, JobGroupLevel, JobGroupLocation, JobGroupDeadline, JobGroupEducationLevel, JobGroupExperience, JobGroupMinSalary, JobGroupMaxSalary, JobGroupRequirements:
		return true
	}
	return false
}

func (e JobGroup) String() string {
	return string(e)
}

func (e *JobGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobGroup", str)
	}
	return nil
}

func (e JobGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for Job a enum of all orderable entities
// can be used f.e.: queryJob
type JobOrderable string

const (
	JobOrderableID             JobOrderable = "id"
	JobOrderableTitle          JobOrderable = "title"
	JobOrderableIndustry       JobOrderable = "industry"
	JobOrderableDescription    JobOrderable = "description"
	JobOrderableLevel          JobOrderable = "level"
	JobOrderableLocation       JobOrderable = "location"
	JobOrderableEducationLevel JobOrderable = "educationLevel"
	JobOrderableExperience     JobOrderable = "experience"
	JobOrderableMinSalary      JobOrderable = "minSalary"
	JobOrderableMaxSalary      JobOrderable = "maxSalary"
	JobOrderableRequirements   JobOrderable = "requirements"
)

var AllJobOrderable = []JobOrderable{
	JobOrderableID,
	JobOrderableTitle,
	JobOrderableIndustry,
	JobOrderableDescription,
	JobOrderableLevel,
	JobOrderableLocation,
	JobOrderableEducationLevel,
	JobOrderableExperience,
	JobOrderableMinSalary,
	JobOrderableMaxSalary,
	JobOrderableRequirements,
}

func (e JobOrderable) IsValid() bool {
	switch e {
	case JobOrderableID, JobOrderableTitle, JobOrderableIndustry, JobOrderableDescription, JobOrderableLevel, JobOrderableLocation, JobOrderableEducationLevel, JobOrderableExperience, JobOrderableMinSalary, JobOrderableMaxSalary, JobOrderableRequirements:
		return true
	}
	return false
}

func (e JobOrderable) String() string {
	return string(e)
}

func (e *JobOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobOrderable", str)
	}
	return nil
}

func (e JobOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  School
// Can be used f.e.: by querySchool
type SchoolGroup string

const (
	SchoolGroupID          SchoolGroup = "id"
	SchoolGroupCreatedAt   SchoolGroup = "createdAt"
	SchoolGroupUpdatedAt   SchoolGroup = "updatedAt"
	SchoolGroupName        SchoolGroup = "name"
	SchoolGroupPhoneNumber SchoolGroup = "phone_number"
	SchoolGroupPassword    SchoolGroup = "password"
	SchoolGroupBadge       SchoolGroup = "badge"
	SchoolGroupWebsite     SchoolGroup = "Website"
)

var AllSchoolGroup = []SchoolGroup{
	SchoolGroupID,
	SchoolGroupCreatedAt,
	SchoolGroupUpdatedAt,
	SchoolGroupName,
	SchoolGroupPhoneNumber,
	SchoolGroupPassword,
	SchoolGroupBadge,
	SchoolGroupWebsite,
}

func (e SchoolGroup) IsValid() bool {
	switch e {
	case SchoolGroupID, SchoolGroupCreatedAt, SchoolGroupUpdatedAt, SchoolGroupName, SchoolGroupPhoneNumber, SchoolGroupPassword, SchoolGroupBadge, SchoolGroupWebsite:
		return true
	}
	return false
}

func (e SchoolGroup) String() string {
	return string(e)
}

func (e *SchoolGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SchoolGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SchoolGroup", str)
	}
	return nil
}

func (e SchoolGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for School a enum of all orderable entities
// can be used f.e.: querySchool
type SchoolOrderable string

const (
	SchoolOrderableID          SchoolOrderable = "id"
	SchoolOrderableName        SchoolOrderable = "name"
	SchoolOrderablePhoneNumber SchoolOrderable = "phone_number"
	SchoolOrderablePassword    SchoolOrderable = "password"
	SchoolOrderableBadge       SchoolOrderable = "badge"
	SchoolOrderableWebsite     SchoolOrderable = "Website"
)

var AllSchoolOrderable = []SchoolOrderable{
	SchoolOrderableID,
	SchoolOrderableName,
	SchoolOrderablePhoneNumber,
	SchoolOrderablePassword,
	SchoolOrderableBadge,
	SchoolOrderableWebsite,
}

func (e SchoolOrderable) IsValid() bool {
	switch e {
	case SchoolOrderableID, SchoolOrderableName, SchoolOrderablePhoneNumber, SchoolOrderablePassword, SchoolOrderableBadge, SchoolOrderableWebsite:
		return true
	}
	return false
}

func (e SchoolOrderable) String() string {
	return string(e)
}

func (e *SchoolOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SchoolOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SchoolOrderable", str)
	}
	return nil
}

func (e SchoolOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  Student
// Can be used f.e.: by queryStudent
type StudentGroup string

const (
	StudentGroupID                 StudentGroup = "id"
	StudentGroupCreatedAt          StudentGroup = "createdAt"
	StudentGroupUpdatedAt          StudentGroup = "updatedAt"
	StudentGroupRegistrationNumber StudentGroup = "registration_number"
	StudentGroupName               StudentGroup = "name"
	StudentGroupPhoneNumber        StudentGroup = "phone_number"
	StudentGroupPassword           StudentGroup = "password"
	StudentGroupDateOfAdmission    StudentGroup = "date_of_admission"
	StudentGroupDateOfBirth        StudentGroup = "date_of_birth"
	StudentGroupProfilePicture     StudentGroup = "profile_picture"
)

var AllStudentGroup = []StudentGroup{
	StudentGroupID,
	StudentGroupCreatedAt,
	StudentGroupUpdatedAt,
	StudentGroupRegistrationNumber,
	StudentGroupName,
	StudentGroupPhoneNumber,
	StudentGroupPassword,
	StudentGroupDateOfAdmission,
	StudentGroupDateOfBirth,
	StudentGroupProfilePicture,
}

func (e StudentGroup) IsValid() bool {
	switch e {
	case StudentGroupID, StudentGroupCreatedAt, StudentGroupUpdatedAt, StudentGroupRegistrationNumber, StudentGroupName, StudentGroupPhoneNumber, StudentGroupPassword, StudentGroupDateOfAdmission, StudentGroupDateOfBirth, StudentGroupProfilePicture:
		return true
	}
	return false
}

func (e StudentGroup) String() string {
	return string(e)
}

func (e *StudentGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StudentGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StudentGroup", str)
	}
	return nil
}

func (e StudentGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for Student a enum of all orderable entities
// can be used f.e.: queryStudent
type StudentOrderable string

const (
	StudentOrderableID                 StudentOrderable = "id"
	StudentOrderableRegistrationNumber StudentOrderable = "registration_number"
	StudentOrderableName               StudentOrderable = "name"
	StudentOrderablePhoneNumber        StudentOrderable = "phone_number"
	StudentOrderablePassword           StudentOrderable = "password"
	StudentOrderableProfilePicture     StudentOrderable = "profile_picture"
)

var AllStudentOrderable = []StudentOrderable{
	StudentOrderableID,
	StudentOrderableRegistrationNumber,
	StudentOrderableName,
	StudentOrderablePhoneNumber,
	StudentOrderablePassword,
	StudentOrderableProfilePicture,
}

func (e StudentOrderable) IsValid() bool {
	switch e {
	case StudentOrderableID, StudentOrderableRegistrationNumber, StudentOrderableName, StudentOrderablePhoneNumber, StudentOrderablePassword, StudentOrderableProfilePicture:
		return true
	}
	return false
}

func (e StudentOrderable) String() string {
	return string(e)
}

func (e *StudentOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StudentOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StudentOrderable", str)
	}
	return nil
}

func (e StudentOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  UnverifiedAdmin
// Can be used f.e.: by queryUnverifiedAdmin
type UnverifiedAdminGroup string

const (
	UnverifiedAdminGroupID          UnverifiedAdminGroup = "id"
	UnverifiedAdminGroupCreatedAt   UnverifiedAdminGroup = "createdAt"
	UnverifiedAdminGroupUpdatedAt   UnverifiedAdminGroup = "updatedAt"
	UnverifiedAdminGroupName        UnverifiedAdminGroup = "name"
	UnverifiedAdminGroupPhoneNumber UnverifiedAdminGroup = "phone_number"
	UnverifiedAdminGroupPassword    UnverifiedAdminGroup = "password"
)

var AllUnverifiedAdminGroup = []UnverifiedAdminGroup{
	UnverifiedAdminGroupID,
	UnverifiedAdminGroupCreatedAt,
	UnverifiedAdminGroupUpdatedAt,
	UnverifiedAdminGroupName,
	UnverifiedAdminGroupPhoneNumber,
	UnverifiedAdminGroupPassword,
}

func (e UnverifiedAdminGroup) IsValid() bool {
	switch e {
	case UnverifiedAdminGroupID, UnverifiedAdminGroupCreatedAt, UnverifiedAdminGroupUpdatedAt, UnverifiedAdminGroupName, UnverifiedAdminGroupPhoneNumber, UnverifiedAdminGroupPassword:
		return true
	}
	return false
}

func (e UnverifiedAdminGroup) String() string {
	return string(e)
}

func (e *UnverifiedAdminGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnverifiedAdminGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnverifiedAdminGroup", str)
	}
	return nil
}

func (e UnverifiedAdminGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for UnverifiedAdmin a enum of all orderable entities
// can be used f.e.: queryUnverifiedAdmin
type UnverifiedAdminOrderable string

const (
	UnverifiedAdminOrderableID          UnverifiedAdminOrderable = "id"
	UnverifiedAdminOrderableName        UnverifiedAdminOrderable = "name"
	UnverifiedAdminOrderablePhoneNumber UnverifiedAdminOrderable = "phone_number"
	UnverifiedAdminOrderablePassword    UnverifiedAdminOrderable = "password"
)

var AllUnverifiedAdminOrderable = []UnverifiedAdminOrderable{
	UnverifiedAdminOrderableID,
	UnverifiedAdminOrderableName,
	UnverifiedAdminOrderablePhoneNumber,
	UnverifiedAdminOrderablePassword,
}

func (e UnverifiedAdminOrderable) IsValid() bool {
	switch e {
	case UnverifiedAdminOrderableID, UnverifiedAdminOrderableName, UnverifiedAdminOrderablePhoneNumber, UnverifiedAdminOrderablePassword:
		return true
	}
	return false
}

func (e UnverifiedAdminOrderable) String() string {
	return string(e)
}

func (e *UnverifiedAdminOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnverifiedAdminOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnverifiedAdminOrderable", str)
	}
	return nil
}

func (e UnverifiedAdminOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  UnverifiedSchool
// Can be used f.e.: by queryUnverifiedSchool
type UnverifiedSchoolGroup string

const (
	UnverifiedSchoolGroupID          UnverifiedSchoolGroup = "id"
	UnverifiedSchoolGroupCreatedAt   UnverifiedSchoolGroup = "createdAt"
	UnverifiedSchoolGroupUpdatedAt   UnverifiedSchoolGroup = "updatedAt"
	UnverifiedSchoolGroupName        UnverifiedSchoolGroup = "name"
	UnverifiedSchoolGroupPhoneNumber UnverifiedSchoolGroup = "phone_number"
	UnverifiedSchoolGroupPassword    UnverifiedSchoolGroup = "password"
	UnverifiedSchoolGroupBadge       UnverifiedSchoolGroup = "badge"
	UnverifiedSchoolGroupWebsite     UnverifiedSchoolGroup = "Website"
)

var AllUnverifiedSchoolGroup = []UnverifiedSchoolGroup{
	UnverifiedSchoolGroupID,
	UnverifiedSchoolGroupCreatedAt,
	UnverifiedSchoolGroupUpdatedAt,
	UnverifiedSchoolGroupName,
	UnverifiedSchoolGroupPhoneNumber,
	UnverifiedSchoolGroupPassword,
	UnverifiedSchoolGroupBadge,
	UnverifiedSchoolGroupWebsite,
}

func (e UnverifiedSchoolGroup) IsValid() bool {
	switch e {
	case UnverifiedSchoolGroupID, UnverifiedSchoolGroupCreatedAt, UnverifiedSchoolGroupUpdatedAt, UnverifiedSchoolGroupName, UnverifiedSchoolGroupPhoneNumber, UnverifiedSchoolGroupPassword, UnverifiedSchoolGroupBadge, UnverifiedSchoolGroupWebsite:
		return true
	}
	return false
}

func (e UnverifiedSchoolGroup) String() string {
	return string(e)
}

func (e *UnverifiedSchoolGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnverifiedSchoolGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnverifiedSchoolGroup", str)
	}
	return nil
}

func (e UnverifiedSchoolGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for UnverifiedSchool a enum of all orderable entities
// can be used f.e.: queryUnverifiedSchool
type UnverifiedSchoolOrderable string

const (
	UnverifiedSchoolOrderableID          UnverifiedSchoolOrderable = "id"
	UnverifiedSchoolOrderableName        UnverifiedSchoolOrderable = "name"
	UnverifiedSchoolOrderablePhoneNumber UnverifiedSchoolOrderable = "phone_number"
	UnverifiedSchoolOrderablePassword    UnverifiedSchoolOrderable = "password"
	UnverifiedSchoolOrderableBadge       UnverifiedSchoolOrderable = "badge"
	UnverifiedSchoolOrderableWebsite     UnverifiedSchoolOrderable = "Website"
)

var AllUnverifiedSchoolOrderable = []UnverifiedSchoolOrderable{
	UnverifiedSchoolOrderableID,
	UnverifiedSchoolOrderableName,
	UnverifiedSchoolOrderablePhoneNumber,
	UnverifiedSchoolOrderablePassword,
	UnverifiedSchoolOrderableBadge,
	UnverifiedSchoolOrderableWebsite,
}

func (e UnverifiedSchoolOrderable) IsValid() bool {
	switch e {
	case UnverifiedSchoolOrderableID, UnverifiedSchoolOrderableName, UnverifiedSchoolOrderablePhoneNumber, UnverifiedSchoolOrderablePassword, UnverifiedSchoolOrderableBadge, UnverifiedSchoolOrderableWebsite:
		return true
	}
	return false
}

func (e UnverifiedSchoolOrderable) String() string {
	return string(e)
}

func (e *UnverifiedSchoolOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnverifiedSchoolOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnverifiedSchoolOrderable", str)
	}
	return nil
}

func (e UnverifiedSchoolOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
