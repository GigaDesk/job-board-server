package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/AlekSi/pointer"
	"github.com/GigaDesk/eardrum-prefix/validate"
	"github.com/GigaDesk/eardrum-server/auth"
	"github.com/GigaDesk/eardrum-server/encrypt"
	"github.com/GigaDesk/eardrum-server/graph/model"
	"github.com/GigaDesk/eardrum-server/phoneutils"
	"github.com/GigaDesk/eardrum-server/pkg/jwt"
	"github.com/GigaDesk/eardrum-server/shutdown"
	"github.com/rs/zerolog/log"
)

// Jobs is the resolver for the jobs field.
func (r *employerProfileResolver) Jobs(ctx context.Context, obj *model.EmployerProfile) ([]*model.JobProfile, error) {
	var jobs []model.Job
	if err := r.Sql.Db.Where("employer_id = ?", obj.ID).Find(&jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("could not access jobs!")
	}
	var jobprofiles []*model.JobProfile

	for _, job := range jobs {
		jobprofile := &model.JobProfile{
			ID:             job.ID,
			CreatedAt:      job.CreatedAt,
			UpdatedAt:      job.UpdatedAt,
			DeletedAt:      job.DeletedAt,
			Title:          job.Title,
			Industry:       job.Industry,
			Description:    job.Description,
			Level:          job.Level,
			Location:       job.Location,
			Deadline:       job.Deadline,
			EducationLevel: job.EducationLevel,
			MinSalary:      job.MinSalary,
			MaxSalary:      job.MaxSalary,
			Experience:     job.Experience,
			JobURL:         job.JobURL,
			Requirements:   strings.Split(pointer.GetString(job.Requirements), "||"),
		}
		jobprofiles = append(jobprofiles, jobprofile)
	}

	return jobprofiles, nil
}

// UnapprovedJobs is the resolver for the unapprovedJobs field.
func (r *employerProfileResolver) UnapprovedJobs(ctx context.Context, obj *model.EmployerProfile) ([]*model.UnapprovedJobProfile, error) {
	var unapprovedjobs []model.UnapprovedJob
	if err := r.Sql.Db.Where("employer_id = ?", obj.ID).Find(&unapprovedjobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("could not access unapproved jobs!")
	}
	var unapprovedjobprofiles []*model.UnapprovedJobProfile

	for _, unapprovedjob := range unapprovedjobs {
		unapprovedjobprofile := &model.UnapprovedJobProfile{
			ID:             unapprovedjob.ID,
			CreatedAt:      unapprovedjob.CreatedAt,
			UpdatedAt:      unapprovedjob.UpdatedAt,
			DeletedAt:      unapprovedjob.DeletedAt,
			Title:          unapprovedjob.Title,
			Industry:       unapprovedjob.Industry,
			Description:    unapprovedjob.Description,
			Level:          unapprovedjob.Level,
			Location:       unapprovedjob.Location,
			Deadline:       unapprovedjob.Deadline,
			EducationLevel: unapprovedjob.EducationLevel,
			MinSalary:      unapprovedjob.MinSalary,
			MaxSalary:      unapprovedjob.MaxSalary,
			Experience:     unapprovedjob.Experience,
			JobURL:         unapprovedjob.JobURL,
			Requirements:   strings.Split(pointer.GetString(unapprovedjob.Requirements), "||"),
		}
		unapprovedjobprofiles = append(unapprovedjobprofiles, unapprovedjobprofile)
	}

	return unapprovedjobprofiles, nil
}

// CreateEmployer is the resolver for the createEmployer field, signs up an employer to the system
func (r *mutationResolver) CreateEmployer(ctx context.Context, input model.NewEmployer) (*model.UnverifiedEmployer, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate inputs
	if err := input.Validate(); err != nil {
		return nil, err
	}
	//check if the phone number exists in the database
	phoneexists, err := phoneutils.CheckEmployerPhoneNumber(r.Sql.Db, input.PhoneNumber)

	//return any error that might be associated with checking the phone number's existence in the database
	if err != nil {
		log.Error().Str("phone_number", input.PhoneNumber).Str("path", "CreateEmployer").Msg(err.Error())
		return nil, errors.New("error checking phone number's existence")
	}
	//return an error if phone number exists in the database
	if phoneexists.Verified == true || phoneexists.Unverified == true {
		return nil, errors.New("phone number already exists")
	}

	//encrypt input password
	encryptedpassword, err := encrypt.HashPassword(input.Password)
	if err != nil {
		log.Error().Str("password", input.Password).Str("path", "CreateEmployer").Msg(err.Error())
		return nil, err
	}
	//create an unverified employer data
	unverifiedemployer := &model.UnverifiedEmployer{
		Name:        input.Name,
		PhoneNumber: input.PhoneNumber,
		Password:    encryptedpassword,
		Badge:       input.Badge,
		Website:     input.Website,
	}
	/*send an OTP code to the phone number associated with the unverified employer record, return error if there is any
		if err := phoneutils.SendOtp(unverifiedemployer.PhoneNumber); err != nil {
			log.Error().Str("phone_number", input.PhoneNumber).Str("path", "CreateEmployer").Msg(err.Error())
			return nil, err
		}
	    OTP defaulted to: 777777 for testing purposes
	*/
	//create an unverified employer record in the database and return if operation succeeds
	if err := r.Sql.Db.Create(unverifiedemployer).Error; err != nil {
		log.Error().Str("name", input.Name).Str("path", "CreateEmployer").Msg(err.Error())
		return nil, errors.New("an unexpected error occurred while creating the employer account. please try again later or contact support")
	}

	return unverifiedemployer, nil
}

// VerifyEmployer is the resolver for the verifyEmployer field. it checks the validity of an OTP code in relation to the phonenumber, if valid it transfers an employer's data from the unverified_employers table to the employer table
func (r *mutationResolver) VerifyEmployer(ctx context.Context, input model.Verificationinfo) (*model.Employer, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate inputs
	if err := input.Validate(); err != nil {
		return nil, err
	}

	/*Check the validity of an OTP code
	if err := phoneutils.CheckOtp(input.PhoneNumber, input.Otp); err != nil {
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/

	if input.Otp != "777777" {
		return nil, errors.New("incorrect OTP code")
	}
	//declare an unverifiedemployer variable
	var unverifiedemployer *model.UnverifiedEmployer

	// Find the first unverified employer that matches the input phone number from the unverified employer table
	if err := r.Sql.Db.Where("phone_number = ?", input.PhoneNumber).First(&unverifiedemployer).Error; err != nil {
		log.Info().Str("phone_number", input.PhoneNumber).Str("path", "VerifyEmployer").Msg("phone number does not exist")
		return nil, errors.New("error finding unverified employer with phone number: " + input.PhoneNumber)
	}

	// transform the unverified employer model into employer model and copy it
	employer := &model.Employer{
		Name:        unverifiedemployer.Name,
		PhoneNumber: unverifiedemployer.PhoneNumber,
		Password:    unverifiedemployer.Password,
		Badge:       unverifiedemployer.Badge,
		Website:     unverifiedemployer.Website,
	}

	// take the newly transformed and copied employer data and transfer it into the official verified employer table
	if err := r.Sql.Db.Create(employer).Error; err != nil {
		log.Info().Str("name", employer.Name).Str("path", "VerifyEmployer").Msg(err.Error())
		return nil, errors.New("Failed to verify employer account. please try again later or contact support")
	}

	// delete the unverified employer from the unverified employer table
	if err := r.Sql.Db.Delete(unverifiedemployer).Error; err != nil {
		log.Error().Str("path", "VerifyEmployer").Int("record_id", unverifiedemployer.ID).Msg(err.Error())
		return nil, errors.New("Failed to complete employer account verification. please try again later or contact support")
	}

	log.Info().Int("initial_record_id", unverifiedemployer.ID).Int("final_record_id", employer.ID).Str("path", "VerifyEmployer").Msg("completed unverified employer to employer data transaction")
	return employer, nil
}

// SendCode is the resolver for the sendCode field, it send an otp code to the provided phone number
func (r *mutationResolver) SendCode(ctx context.Context, phoneNumber string) (*model.SendCodeStatus, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate phone number
	if err := validate.ValidateKenyanPhoneNumber(phoneNumber); err != nil {
		return nil, err
	}
	/*
		if err := phoneutils.SendOtp(phoneNumber); err != nil {
			log.Error().Str("phone_number", phoneNumber).Str("path", "SendCode").Msg(err.Error())
			return nil, err
			OTP defaulted to: 777777 for testing purposes
		}
	*/
	sendcodestatus := &model.SendCodeStatus{
		PhoneNumber: phoneNumber,
		Success:     true,
	}
	return sendcodestatus, nil
}

// EmployerLogin is the resolver for the employerLogin field.
func (r *mutationResolver) EmployerLogin(ctx context.Context, input model.EmployerLogin) (*string, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	//validate EmployerLogin input
	if err := input.Validate(); err != nil {
		return nil, err
	}

	//declare an employer variable
	var employer *model.Employer
	// Find the first employer that matches the input phone number from the employer table

	if err := r.Sql.Db.Where("phone_number = ?", input.PhoneNumber).First(&employer).Error; err != nil {
		log.Info().Str("phone_number", input.PhoneNumber).Str("path", "EmployerLogin").Msg(err.Error())
		return nil, errors.New("phone number does not exist")
	}
	//check if the password of the employer matches the input password
	if err := encrypt.CheckPassword(employer.Password, input.Password); err != nil {
		log.Info().Str("path", "EmployerLogin").Msg(err.Error())
		return nil, errors.New("Invalid phone number or password")
	}

	credentials := jwt.TokenCredentials{
		Id:   strconv.Itoa(employer.ID),
		Role: "employer",
	}
	token, err := jwt.GenerateToken(credentials)
	if err != nil {
		log.Error().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "EmployerLogin").Msg(err.Error())
		return nil, errors.New("error generating accessToken")
	}
	log.Info().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "EmployerLogin").Msg("employer logged in successfully!")
	return &token, nil
}

// ForgotEmployerPassword is the resolver for the forgotEmployerPassword field.
func (r *mutationResolver) ForgotEmployerPassword(ctx context.Context, phoneNumber string) (*model.SendCodeStatus, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	//validate phone number
	if err := validate.ValidateKenyanPhoneNumber(phoneNumber); err != nil {
		return nil, err
	}

	//check if the phone number exists in the database
	phoneexists, err := phoneutils.CheckEmployerPhoneNumber(r.Sql.Db, phoneNumber)

	//return any error that might be associated with checking the phone number's existence in the database
	if err != nil {
		log.Error().Str("phone_number", phoneNumber).Str("path", "ForgotEmployerPassword").Msg(err.Error())
		return nil, err
	}
	//return an error if phone number exists in the unverified employer table
	if phoneexists.Verified != true && phoneexists.Unverified == true {
		return nil, errors.New("phone number has been registered but is yet to be verified")
	}
	//return an error if phone number is neither registered nor verified
	if phoneexists.Verified != true && phoneexists.Unverified != true {
		return nil, errors.New("phone number does not exist")
	}
	/*send an OTP code to the phone number provided, return error if there is any
	if err := phoneutils.SendOtp(phoneNumber); err != nil {
		log.Error().Str("phone_number", phoneNumber).Str("path", "ForgotEmployerPassword").Msg(err.Error())
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/
	//return status on success
	sendcodestatus := &model.SendCodeStatus{
		PhoneNumber: phoneNumber,
		Success:     true,
	}
	return sendcodestatus, nil
}

// RequestEmployerPasswordReset is the resolver for the requestEmployerPasswordReset field.
func (r *mutationResolver) RequestEmployerPasswordReset(ctx context.Context, input *model.Verificationinfo) (*string, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate inputs
	if err := input.Validate(); err != nil {
		return nil, err
	}

	/*Check the validity of an OTP code
	if err := phoneutils.CheckOtp(input.PhoneNumber, input.Otp); err != nil {
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/
	if input.Otp != "777777" {
		return nil, errors.New("incorrect OTP code")
	}

	//declare an employer variable
	var employer *model.Employer

	// Find the first employer that matches the input phone number from the employer table

	if err := r.Sql.Db.Where("phone_number = ?", input.PhoneNumber).First(&employer).Error; err != nil {
		log.Info().Str("phone_number", input.PhoneNumber).Str("path", "RequestEmployerPasswordReset").Msg(err.Error())
		return nil, errors.New("phone number does not exist")
	}

	credentials := jwt.TokenCredentials{
		Id:   strconv.Itoa(employer.ID),
		Role: "employer",
	}
	token, err := jwt.GenerateToken(credentials)
	if err != nil {
		log.Error().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "RequestEmployerPasswordReset").Msg(err.Error())
		return nil, errors.New("error generating accessToken")
	}
	return &token, nil
}

// ResetEmployerPassword is the resolver for the ResetEmployerPassword field.
func (r *mutationResolver) ResetEmployerPassword(ctx context.Context, newPassword string) (*model.Employer, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	user, err := auth.ForContext(ctx)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, errors.New("access to reset employer password denied!")
	}
	role := user.GetRole()
	if role != "employer" {
		return nil, errors.New("access to reset employer password denied. Only available for registered and logged in employers. To fix check access token!")
	}
	id, err := user.GetID()

	if err != nil {
		errors.New("could not access employer's id!")
	}

	//validate inputs
	if err := validate.ValidatePassword(newPassword); err != nil {
		return nil, err
	}

	var employer *model.Employer
	//fetch the record to be updated from the database
	if err := r.Sql.Db.First(&employer, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "ResetEmployerPassword").Msg(err.Error())
		return nil, err
	}
	//encrypt input password
	encryptedpassword, err := encrypt.HashPassword(newPassword)
	if err != nil {
		log.Error().Str("password", newPassword).Str("path", "ResetEmployerPassword").Msg(err.Error())
		return nil, err
	}
	// Update the records' attributes with `map`
	if err := r.Sql.Db.Model(&employer).Updates(map[string]interface{}{"password": encryptedpassword}).Error; err != nil {
		log.Error().Int("id", employer.ID).Str("path", "ResetEmployerPassword").Msg(fmt.Sprintf("updating employer password failed: %s", err.Error()))
		return nil, err
	}

	//fetch the record again from the database, this time the updated version
	if err := r.Sql.Db.First(&employer, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "ResetEmployerPassword").Msg(err.Error())
		return nil, err
	}

	//return the updated record
	return employer, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input *model.RefreshTokenInput) (*string, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	credentials, err := jwt.ParseToken(input.Token)
	if err != nil {
		return nil, fmt.Errorf("access denied")
	}
	token, error := jwt.GenerateToken(*credentials)
	if error != nil {
		log.Error().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "RefreshToken").Msg(err.Error())
		return nil, error
	}
	return &token, nil
}

// EditEmployerProfile is the resolver for the editEmployerProfile field.
func (r *mutationResolver) EditEmployerProfile(ctx context.Context, input model.UpdatedEmployer) (*model.EmployerProfile, error) {
	user, err := auth.ForContext(ctx)

	if err != nil {
		return nil, err
	}

	id, err := user.GetID()

	if err != nil {
		errors.New("could not access employer's id!")
	}

	//declare an employer variable
	var employer *model.Employer

	//Find the first employer that matches the input id
	if err := r.Sql.Db.Where("id = ?", id).First(&employer).Error; err != nil {
		log.Info().Int("id", id).Str("path", "EditEmployerProfile").Msg("id does not exist")
		return nil, errors.New("error finding employer with id: " + strconv.Itoa(id))
	}

	employer.Name = input.Name
	employer.PhoneNumber = input.PhoneNumber
	employer.Badge = input.Badge
	employer.Website = input.Website

	// Update employer record
	if err := r.Sql.Db.Save(&employer).Error; err != nil {
		log.Info().Int("id", id).Str("path", "EditEmployerProfile").Msg("failed to update employer")
		return nil, errors.New("error updating employer with id: " + strconv.Itoa(id))
	}

	employerprofile := &model.EmployerProfile{
		ID:          employer.ID,
		CreatedAt:   employer.CreatedAt,
		UpdatedAt:   employer.UpdatedAt,
		Name:        employer.Name,
		PhoneNumber: employer.PhoneNumber,
		Badge:       employer.Badge,
		Website:     employer.Website,
	}

	return employerprofile, nil
}

// EmployerPhoneNumberExists is the resolver for the employerPhoneNumberExists field, checks if an employer's phone number already exists in both the unverified_employers and employers tables
func (r *queryResolver) EmployerPhoneNumberExists(ctx context.Context, phoneNumber string) (*model.PhoneNumberExists, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	phoneexists, err := phoneutils.CheckEmployerPhoneNumber(r.Sql.Db, phoneNumber)

	if err != nil {
		log.Error().Str("phone_number", phoneNumber).Str("path", "EmployerPhoneNumberExists").Msg(err.Error())
		return nil, err
	}

	return phoneexists, nil
}

// GetEmployerProfile is the resolver for the getEmployerProfile field.
func (r *queryResolver) GetEmployerProfile(ctx context.Context) (*model.EmployerProfile, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	user, err := auth.ForContext(ctx)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, errors.New("access to getEmployer profile denied!")
	}
	role := user.GetRole()
	if role != "employer" {
		return nil, errors.New("access to getEmployer profile denied. Only available for registered and logged in employers. To fix check access token!")
	}
	id, err := user.GetID()

	if err != nil {
		errors.New("could not access employer's id!")
	}

	var employer *model.Employer
	if err := r.Sql.Db.First(&employer, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "GetEmployerProfile").Msg(err.Error())
		return nil, errors.New("could not access employer's profile!")
	}
	log.Info().Int("id", id).Str("role", role).Str("path", "GetEmployerProfile").Msg("getting employer's profile")
	employerprofile := &model.EmployerProfile{
		ID:          employer.ID,
		CreatedAt:   employer.CreatedAt,
		UpdatedAt:   employer.UpdatedAt,
		Name:        employer.Name,
		PhoneNumber: employer.PhoneNumber,
		Badge:       employer.Badge,
		Website:     employer.Website,
	}
	return employerprofile, nil
}

// GetEmployersProfile is the resolver for the getEmployersProfile field.
func (r *queryResolver) GetEmployersProfile(ctx context.Context) ([]*model.EmployerProfile, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	var employers []*model.Employer
	if err := r.Sql.Db.Find(&employers).Error; err != nil {
		log.Error().Str("path", "GetEmployersProfile").Msg(err.Error())
		return nil, errors.New("could not access employers' profile!")
	}
	log.Info().Str("path", "GetEmployersProfile").Msg("getting employers' profile")

	var employersprofile []*model.EmployerProfile

	for _, employer := range employers {
		employerprofile := &model.EmployerProfile{
			ID:          employer.ID,
			CreatedAt:   employer.CreatedAt,
			UpdatedAt:   employer.UpdatedAt,
			Name:        employer.Name,
			PhoneNumber: employer.PhoneNumber,
			Badge:       employer.Badge,
			Website:     employer.Website,
		}
		employersprofile = append(employersprofile, employerprofile)
	}

	return employersprofile, nil
}

// FindEmployer is the resolver for the findEmployer field.
func (r *queryResolver) FindEmployer(ctx context.Context, id int) (*model.EmployerProfile, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	//declare an employer variable
	var employer *model.Employer

	// Find the first employer that matches the input id from the employer table
	if err := r.Sql.Db.Where("id = ?", id).First(&employer).Error; err != nil {
		log.Info().Int("id", id).Str("path", "FindEmployer").Msg("id does not exist")
		return nil, errors.New("error finding employer with id: " + strconv.Itoa(id))
	}

	employerprofile := &model.EmployerProfile{
		ID:          employer.ID,
		CreatedAt:   employer.CreatedAt,
		UpdatedAt:   employer.UpdatedAt,
		Name:        employer.Name,
		PhoneNumber: employer.PhoneNumber,
		Badge:       employer.Badge,
		Website:     employer.Website,
	}

	return employerprofile, nil
}

// EmployerProfile returns EmployerProfileResolver implementation.
func (r *Resolver) EmployerProfile() EmployerProfileResolver { return &employerProfileResolver{r} }

type employerProfileResolver struct{ *Resolver }
