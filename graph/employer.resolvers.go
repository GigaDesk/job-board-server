package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/AlekSi/pointer"
	"github.com/GigaDesk/eardrum-prefix/validate"
	"github.com/GigaDesk/eardrum-server/auth"
	"github.com/GigaDesk/eardrum-server/encrypt"
	"github.com/GigaDesk/eardrum-server/graph/model"
	"github.com/GigaDesk/eardrum-server/phoneutils"
	"github.com/GigaDesk/eardrum-server/pkg/jwt"
	"github.com/GigaDesk/eardrum-server/shutdown"
	"github.com/rs/zerolog/log"
)

// Jobs is the resolver for the jobs field.
func (r *employerProfileResolver) Jobs(ctx context.Context, obj *model.EmployerProfile) ([]*model.JobProfile, error) {
	var jobs []model.Job
	if err := r.Sql.Db.Where("employer_id = ?", obj.ID).Find(&jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("could not access jobs!")
	}
	var jobprofiles []*model.JobProfile

	for _, job := range jobs {
		jobprofile := &model.JobProfile{
			ID:             job.ID,
			CreatedAt:      job.CreatedAt,
			UpdatedAt:      job.UpdatedAt,
			DeletedAt:      job.DeletedAt,
			Title:          job.Title,
			Industry:       job.Industry,
			Description:    job.Description,
			Level:          job.Level,
			Location:       job.Location,
			Deadline:       job.Deadline,
			EducationLevel: job.EducationLevel,
			MinSalary:      job.MinSalary,
			MaxSalary:      job.MaxSalary,
			Experience:     job.Experience,
			JobURL:         job.JobURL,
			Requirements:   strings.Split(pointer.GetString(job.Requirements), "||"),
		}
		jobprofiles = append(jobprofiles, jobprofile)
	}

	return jobprofiles, nil
}

// UnapprovedJobs is the resolver for the unapprovedJobs field.
func (r *employerProfileResolver) UnapprovedJobs(ctx context.Context, obj *model.EmployerProfile) ([]*model.UnapprovedJobProfile, error) {
	var unapprovedjobs []model.UnapprovedJob
	if err := r.Sql.Db.Where("employer_id = ?", obj.ID).Find(&unapprovedjobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("could not access unapproved jobs!")
	}
	var unapprovedjobprofiles []*model.UnapprovedJobProfile

	for _, unapprovedjob := range unapprovedjobs {
		unapprovedjobprofile := &model.UnapprovedJobProfile{
			ID:             unapprovedjob.ID,
			CreatedAt:      unapprovedjob.CreatedAt,
			UpdatedAt:      unapprovedjob.UpdatedAt,
			DeletedAt:      unapprovedjob.DeletedAt,
			Title:          unapprovedjob.Title,
			Industry:       unapprovedjob.Industry,
			Description:    unapprovedjob.Description,
			Level:          unapprovedjob.Level,
			Location:       unapprovedjob.Location,
			Deadline:       unapprovedjob.Deadline,
			EducationLevel: unapprovedjob.EducationLevel,
			MinSalary:      unapprovedjob.MinSalary,
			MaxSalary:      unapprovedjob.MaxSalary,
			Experience:     unapprovedjob.Experience,
			JobURL:         unapprovedjob.JobURL,
			Requirements:   strings.Split(pointer.GetString(unapprovedjob.Requirements), "||"),
		}
		unapprovedjobprofiles = append(unapprovedjobprofiles, unapprovedjobprofile)
	}

	return unapprovedjobprofiles, nil
}

// Analytics is the resolver for the analytics field.
func (r *employerProfileResolver) Analytics(ctx context.Context, obj *model.EmployerProfile) (*model.EmployerAnalytics, error) {

	//for approved jobs
	var total_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("employer_id = ?", obj.ID).Count(&total_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting total employer jobs!")
	}

	var diploma_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("employer_id = ?", obj.ID).Where("education_level = ?", "Diploma").Count(&diploma_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting diploma jobs!")
	}

	var bachelors_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("employer_id = ?", obj.ID).Where("education_level = ?", "Bachelor's Degree").Count(&bachelors_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting bachelors jobs!")
	}

	var masters_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("employer_id = ?", obj.ID).Where("education_level = ?", "Master's Degree").Count(&masters_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting masters jobs!")
	}

	var phd_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("employer_id = ?", obj.ID).Where("education_level = ?", "PhD").Count(&phd_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting phd jobs!")
	}

	job_education_level_analytics := model.JobEducationLevelAnalytics{
		Diploma:         int(diploma_jobs),
		BachelorsDegree: int(bachelors_jobs),
		MastersDegree:   int(masters_jobs),
		Phd:             int(phd_jobs),
		Unspecified:     int(total_jobs) - int(diploma_jobs) - int(bachelors_jobs) - int(masters_jobs) - int(phd_jobs),
	}

	//for unapproved jobs

	var total_unapproved_jobs int64

	if err := r.Sql.Db.Model(&model.UnapprovedJob{}).Where("employer_id = ?", obj.ID).Count(&total_unapproved_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting total employer unapproved jobs!")
	}

	var unapproved_diploma_jobs int64

	if err := r.Sql.Db.Model(&model.UnapprovedJob{}).Where("employer_id = ?", obj.ID).Where("education_level = ?", "Diploma").Count(&unapproved_diploma_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting unapproved diploma jobs!")
	}

	var unapproved_bachelors_jobs int64

	if err := r.Sql.Db.Model(&model.UnapprovedJob{}).Where("employer_id = ?", obj.ID).Where("education_level = ?", "Bachelor's Degree").Count(&unapproved_bachelors_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting unapproved bachelors jobs!")
	}

	var unapproved_masters_jobs int64

	if err := r.Sql.Db.Model(&model.UnapprovedJob{}).Where("employer_id = ?", obj.ID).Where("education_level = ?", "Master's Degree").Count(&unapproved_masters_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting unapproved masters jobs!")
	}

	var unapproved_phd_jobs int64

	if err := r.Sql.Db.Model(&model.UnapprovedJob{}).Where("employer_id = ?", obj.ID).Where("education_level = ?", "PhD").Count(&unapproved_phd_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting phd jobs!")
	}

	unapprovedjob_education_level_analytics := model.JobEducationLevelAnalytics{
		Diploma:         int(unapproved_diploma_jobs),
		BachelorsDegree: int(unapproved_bachelors_jobs),
		MastersDegree:   int(unapproved_masters_jobs),
		Phd:             int(unapproved_phd_jobs),
		Unspecified:     int(total_unapproved_jobs) - int(unapproved_diploma_jobs) - int(unapproved_bachelors_jobs) - int(unapproved_masters_jobs) - int(unapproved_phd_jobs),
	}

	//for approved jobs
	var beginner_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("employer_id = ?", obj.ID).Where("level = ?", "Beginner").Count(&beginner_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting beginner jobs!")
	}

	var intermediate_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("employer_id = ?", obj.ID).Where("level = ?", "Intermediate").Count(&intermediate_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting intermediate jobs!")
	}

	var senior_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("employer_id = ?", obj.ID).Where("level = ?", "Senior").Count(&senior_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting senior jobs!")
	}

	job_seniority_level_analytics := model.JobSeniorityLevelAnalytics{
		Beginner:     int(beginner_jobs),
		Intermediate: int(intermediate_jobs),
		Senior:       int(senior_jobs),
		Unspecified:  int(total_jobs) - int(beginner_jobs) - int(intermediate_jobs) - int(senior_jobs),
	}

	//for unapproved jobs
	var unapproved_beginner_jobs int64

	if err := r.Sql.Db.Model(&model.UnapprovedJob{}).Where("employer_id = ?", obj.ID).Where("level = ?", "Beginner").Count(&unapproved_beginner_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting unapproved beginner jobs!")
	}

	var unapproved_intermediate_jobs int64

	if err := r.Sql.Db.Model(&model.UnapprovedJob{}).Where("employer_id = ?", obj.ID).Where("level = ?", "Intermediate").Count(&unapproved_intermediate_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting unapproved intermediate jobs!")
	}

	var unapproved_senior_jobs int64

	if err := r.Sql.Db.Model(&model.UnapprovedJob{}).Where("employer_id = ?", obj.ID).Where("level = ?", "Senior").Count(&unapproved_senior_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting unapproved senior jobs!")
	}

	unapproved_job_seniority_level_analytics := model.JobSeniorityLevelAnalytics{
		Beginner:     int(unapproved_beginner_jobs),
		Intermediate: int(unapproved_intermediate_jobs),
		Senior:       int(unapproved_senior_jobs),
		Unspecified:  int(total_unapproved_jobs) - int(unapproved_beginner_jobs) - int(unapproved_intermediate_jobs) - int(unapproved_senior_jobs),
	}

	//for approved jobs
	var one_to_three_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("employer_id = ?", obj.ID).Where("experience < ? AND experience >= ?", "3", "1").Count(&one_to_three_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting one to three years of experience jobs!")
	}

	var three_to_five_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("employer_id = ?", obj.ID).Where("experience < ? AND experience >= ?", "5", "3").Count(&three_to_five_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting three to five years of experience jobs!")
	}

	var five_to_seven_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("employer_id = ?", obj.ID).Where("experience < ? AND experience >= ?", "7", "5").Count(&five_to_seven_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting five to seven years of experience jobs!")
	}

	var seven_to_nine_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("employer_id = ?", obj.ID).Where("experience < ? AND experience >= ?", "9", "7").Count(&seven_to_nine_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting seven to nine years of experience jobs!")
	}

	var nine_and_above_jobs int64

	if err := r.Sql.Db.Model(&model.Job{}).Where("employer_id = ?", obj.ID).Where("experience >= ?", "9").Count(&nine_and_above_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting nine and above years of experience jobs!")
	}

	job_experience_analytics := model.JobExperienceAnalytics{
		BelowOne:     int(total_jobs) - int(one_to_three_jobs) - int(three_to_five_jobs) - int(five_to_seven_jobs) - int(seven_to_nine_jobs) - int(nine_and_above_jobs),
		OneToThree:   int(one_to_three_jobs),
		ThreeToFive:  int(three_to_five_jobs),
		FiveToSeven:  int(five_to_seven_jobs),
		SevenToNine:  int(seven_to_nine_jobs),
		NineAndAbove: int(nine_and_above_jobs),
	}

	//for unapproved jobs
	var unapproved_one_to_three_jobs int64

	if err := r.Sql.Db.Model(&model.UnapprovedJob{}).Where("employer_id = ?", obj.ID).Where("experience < ? AND experience >= ?", "3", "1").Count(&unapproved_one_to_three_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting one to three years of experience unapproved jobs!")
	}

	var unapproved_three_to_five_jobs int64

	if err := r.Sql.Db.Model(&model.UnapprovedJob{}).Where("employer_id = ?", obj.ID).Where("experience < ? AND experience >= ?", "5", "3").Count(&unapproved_three_to_five_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting three to five years of experience unapproved jobs!")
	}

	var unapproved_five_to_seven_jobs int64

	if err := r.Sql.Db.Model(&model.UnapprovedJob{}).Where("employer_id = ?", obj.ID).Where("experience < ? AND experience >= ?", "7", "5").Count(&unapproved_five_to_seven_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting five to seven years of experience unapproved jobs!")
	}

	var unapproved_seven_to_nine_jobs int64

	if err := r.Sql.Db.Model(&model.UnapprovedJob{}).Where("employer_id = ?", obj.ID).Where("experience < ? AND experience >= ?", "9", "7").Count(&unapproved_seven_to_nine_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting seven to nine years of experience unapproved jobs!")
	}

	var unapproved_nine_and_above_jobs int64

	if err := r.Sql.Db.Model(&model.UnapprovedJob{}).Where("employer_id = ?", obj.ID).Where("experience >= ?", "9").Count(&unapproved_nine_and_above_jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting nine and above years of experience unapproved jobs!")
	}

	unapproved_job_experience_analytics := model.JobExperienceAnalytics{
		BelowOne:     int(total_unapproved_jobs) - int(unapproved_one_to_three_jobs) - int(unapproved_three_to_five_jobs) - int(unapproved_five_to_seven_jobs) - int(unapproved_seven_to_nine_jobs) - int(unapproved_nine_and_above_jobs),
		OneToThree:   int(unapproved_one_to_three_jobs),
		ThreeToFive:  int(unapproved_three_to_five_jobs),
		FiveToSeven:  int(unapproved_five_to_seven_jobs),
		SevenToNine:  int(unapproved_seven_to_nine_jobs),
		NineAndAbove: int(unapproved_nine_and_above_jobs),
	}

	//count all applications to employer's jobs

	var jobs []model.Job

	if err := r.Sql.Db.Where("employer_id = ?", obj.ID).Find(&jobs).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("could not access jobs!")
	}

	var jobIds []int

	for _, job := range jobs {
		jobIds = append(jobIds, job.ID)
	}

	var total_applications int64

	if err := r.Sql.Db.Model(&model.Application{}).Where("job_id IN ?", jobIds).Count(&total_applications).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting total applications!")
	}

	var pending_applications int64

	if err := r.Sql.Db.Model(&model.Application{}).Where("job_id IN ?", jobIds).Where("status = ?", "pending").Count(&pending_applications).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting pending applications!")
	}

	var accepted_applications int64

	if err := r.Sql.Db.Model(&model.Application{}).Where("job_id IN ?", jobIds).Where("status = ?", "accepted").Count(&accepted_applications).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting accepted applications!")
	}

	var rejected_applications int64

	if err := r.Sql.Db.Model(&model.Application{}).Where("job_id IN ?", jobIds).Where("status = ?", "rejected").Count(&rejected_applications).Error; err != nil {
		log.Error().Str("object", "EmployerProfile").Msg(err.Error())
		return nil, errors.New("error counting rejected applications!")
	}

	applications_analytics := model.ApplicationAnalytics{
		Total:    int(total_applications),
		Pending:  int(pending_applications),
		Accepted: int(accepted_applications),
		Rejected: int(rejected_applications),
	}

	job_approval_analytics := model.JobApprovalAnalytics{
		UnapprovedJobs: int(total_unapproved_jobs),
		Approvedjobs:   int(total_jobs),
	}

	analytics := &model.EmployerAnalytics{
		ApplicationsStatus:           &applications_analytics,
		JobsEducationLevel:           &job_education_level_analytics,
		UnapprovedjobsEducationLevel: &unapprovedjob_education_level_analytics,
		JobsExperience:               &job_experience_analytics,
		UnapprovedjobsExperience:     &unapproved_job_experience_analytics,
		JobsSeniority:                &job_seniority_level_analytics,
		UnapprovedjobsSeniority:      &unapproved_job_seniority_level_analytics,
		JobsApproval:                 &job_approval_analytics,
	}

	return analytics, nil

}

// CreateEmployer is the resolver for the createEmployer field, signs up an employer to the system
func (r *mutationResolver) CreateEmployer(ctx context.Context, input model.NewEmployer) (*model.UnverifiedEmployer, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate inputs
	if err := input.Validate(); err != nil {
		return nil, err
	}
	//check if the phone number exists in the database
	phoneexists, err := phoneutils.CheckEmployerPhoneNumber(r.Sql.Db, input.PhoneNumber)

	//return any error that might be associated with checking the phone number's existence in the database
	if err != nil {
		log.Error().Str("phone_number", input.PhoneNumber).Str("path", "CreateEmployer").Msg(err.Error())
		return nil, errors.New("error checking phone number's existence")
	}
	//return an error if phone number exists in the database
	if phoneexists.Verified == true || phoneexists.Unverified == true {
		return nil, errors.New("phone number already exists")
	}

	//encrypt input password
	encryptedpassword, err := encrypt.HashPassword(input.Password)
	if err != nil {
		log.Error().Str("password", input.Password).Str("path", "CreateEmployer").Msg(err.Error())
		return nil, err
	}
	//create an unverified employer data
	unverifiedemployer := &model.UnverifiedEmployer{
		Name:        input.Name,
		PhoneNumber: input.PhoneNumber,
		Password:    encryptedpassword,
		Badge:       input.Badge,
		Website:     input.Website,
	}
	/*send an OTP code to the phone number associated with the unverified employer record, return error if there is any
		if err := phoneutils.SendOtp(unverifiedemployer.PhoneNumber); err != nil {
			log.Error().Str("phone_number", input.PhoneNumber).Str("path", "CreateEmployer").Msg(err.Error())
			return nil, err
		}
	    OTP defaulted to: 777777 for testing purposes
	*/
	//create an unverified employer record in the database and return if operation succeeds
	if err := r.Sql.Db.Create(unverifiedemployer).Error; err != nil {
		log.Error().Str("name", input.Name).Str("path", "CreateEmployer").Msg(err.Error())
		return nil, errors.New("an unexpected error occurred while creating the employer account. please try again later or contact support")
	}

	return unverifiedemployer, nil
}

// VerifyEmployer is the resolver for the verifyEmployer field. it checks the validity of an OTP code in relation to the phonenumber, if valid it transfers an employer's data from the unverified_employers table to the employer table
func (r *mutationResolver) VerifyEmployer(ctx context.Context, input model.Verificationinfo) (*model.Employer, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate inputs
	if err := input.Validate(); err != nil {
		return nil, err
	}

	/*Check the validity of an OTP code
	if err := phoneutils.CheckOtp(input.PhoneNumber, input.Otp); err != nil {
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/

	if input.Otp != "777777" {
		return nil, errors.New("incorrect OTP code")
	}
	//declare an unverifiedemployer variable
	var unverifiedemployer *model.UnverifiedEmployer

	// Find the first unverified employer that matches the input phone number from the unverified employer table
	if err := r.Sql.Db.Where("phone_number = ?", input.PhoneNumber).First(&unverifiedemployer).Error; err != nil {
		log.Info().Str("phone_number", input.PhoneNumber).Str("path", "VerifyEmployer").Msg("phone number does not exist")
		return nil, errors.New("error finding unverified employer with phone number: " + input.PhoneNumber)
	}

	// transform the unverified employer model into employer model and copy it
	employer := &model.Employer{
		Name:        unverifiedemployer.Name,
		PhoneNumber: unverifiedemployer.PhoneNumber,
		Password:    unverifiedemployer.Password,
		Badge:       unverifiedemployer.Badge,
		Website:     unverifiedemployer.Website,
	}

	// take the newly transformed and copied employer data and transfer it into the official verified employer table
	if err := r.Sql.Db.Create(employer).Error; err != nil {
		log.Info().Str("name", employer.Name).Str("path", "VerifyEmployer").Msg(err.Error())
		return nil, errors.New("Failed to verify employer account. please try again later or contact support")
	}

	// delete the unverified employer from the unverified employer table
	if err := r.Sql.Db.Delete(unverifiedemployer).Error; err != nil {
		log.Error().Str("path", "VerifyEmployer").Int("record_id", unverifiedemployer.ID).Msg(err.Error())
		return nil, errors.New("Failed to complete employer account verification. please try again later or contact support")
	}

	log.Info().Int("initial_record_id", unverifiedemployer.ID).Int("final_record_id", employer.ID).Str("path", "VerifyEmployer").Msg("completed unverified employer to employer data transaction")
	return employer, nil
}

// SendCode is the resolver for the sendCode field, it send an otp code to the provided phone number
func (r *mutationResolver) SendCode(ctx context.Context, phoneNumber string) (*model.SendCodeStatus, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate phone number
	if err := validate.ValidateKenyanPhoneNumber(phoneNumber); err != nil {
		return nil, err
	}
	/*
		if err := phoneutils.SendOtp(phoneNumber); err != nil {
			log.Error().Str("phone_number", phoneNumber).Str("path", "SendCode").Msg(err.Error())
			return nil, err
			OTP defaulted to: 777777 for testing purposes
		}
	*/
	sendcodestatus := &model.SendCodeStatus{
		PhoneNumber: phoneNumber,
		Success:     true,
	}
	return sendcodestatus, nil
}

// EmployerLogin is the resolver for the employerLogin field.
func (r *mutationResolver) EmployerLogin(ctx context.Context, input model.EmployerLogin) (*string, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	//validate EmployerLogin input
	if err := input.Validate(); err != nil {
		return nil, err
	}

	//declare an employer variable
	var employer *model.Employer
	// Find the first employer that matches the input phone number from the employer table

	if err := r.Sql.Db.Where("phone_number = ?", input.PhoneNumber).First(&employer).Error; err != nil {
		log.Info().Str("phone_number", input.PhoneNumber).Str("path", "EmployerLogin").Msg(err.Error())
		return nil, errors.New("phone number does not exist")
	}
	//check if the password of the employer matches the input password
	if err := encrypt.CheckPassword(employer.Password, input.Password); err != nil {
		log.Info().Str("path", "EmployerLogin").Msg(err.Error())
		return nil, errors.New("Invalid phone number or password")
	}

	credentials := jwt.TokenCredentials{
		Id:   strconv.Itoa(employer.ID),
		Role: "employer",
	}
	token, err := jwt.GenerateToken(credentials)
	if err != nil {
		log.Error().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "EmployerLogin").Msg(err.Error())
		return nil, errors.New("error generating accessToken")
	}
	log.Info().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "EmployerLogin").Msg("employer logged in successfully!")
	return &token, nil
}

// ForgotEmployerPassword is the resolver for the forgotEmployerPassword field.
func (r *mutationResolver) ForgotEmployerPassword(ctx context.Context, phoneNumber string) (*model.SendCodeStatus, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	//validate phone number
	if err := validate.ValidateKenyanPhoneNumber(phoneNumber); err != nil {
		return nil, err
	}

	//check if the phone number exists in the database
	phoneexists, err := phoneutils.CheckEmployerPhoneNumber(r.Sql.Db, phoneNumber)

	//return any error that might be associated with checking the phone number's existence in the database
	if err != nil {
		log.Error().Str("phone_number", phoneNumber).Str("path", "ForgotEmployerPassword").Msg(err.Error())
		return nil, err
	}
	//return an error if phone number exists in the unverified employer table
	if phoneexists.Verified != true && phoneexists.Unverified == true {
		return nil, errors.New("phone number has been registered but is yet to be verified")
	}
	//return an error if phone number is neither registered nor verified
	if phoneexists.Verified != true && phoneexists.Unverified != true {
		return nil, errors.New("phone number does not exist")
	}
	/*send an OTP code to the phone number provided, return error if there is any
	if err := phoneutils.SendOtp(phoneNumber); err != nil {
		log.Error().Str("phone_number", phoneNumber).Str("path", "ForgotEmployerPassword").Msg(err.Error())
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/
	//return status on success
	sendcodestatus := &model.SendCodeStatus{
		PhoneNumber: phoneNumber,
		Success:     true,
	}
	return sendcodestatus, nil
}

// RequestEmployerPasswordReset is the resolver for the requestEmployerPasswordReset field.
func (r *mutationResolver) RequestEmployerPasswordReset(ctx context.Context, input *model.Verificationinfo) (*string, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	//validate inputs
	if err := input.Validate(); err != nil {
		return nil, err
	}

	/*Check the validity of an OTP code
	if err := phoneutils.CheckOtp(input.PhoneNumber, input.Otp); err != nil {
		return nil, err
	}
	OTP defaulted to: 777777 for testing purposes
	*/
	if input.Otp != "777777" {
		return nil, errors.New("incorrect OTP code")
	}

	//declare an employer variable
	var employer *model.Employer

	// Find the first employer that matches the input phone number from the employer table

	if err := r.Sql.Db.Where("phone_number = ?", input.PhoneNumber).First(&employer).Error; err != nil {
		log.Info().Str("phone_number", input.PhoneNumber).Str("path", "RequestEmployerPasswordReset").Msg(err.Error())
		return nil, errors.New("phone number does not exist")
	}

	credentials := jwt.TokenCredentials{
		Id:   strconv.Itoa(employer.ID),
		Role: "employer",
	}
	token, err := jwt.GenerateToken(credentials)
	if err != nil {
		log.Error().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "RequestEmployerPasswordReset").Msg(err.Error())
		return nil, errors.New("error generating accessToken")
	}
	return &token, nil
}

// ResetEmployerPassword is the resolver for the ResetEmployerPassword field.
func (r *mutationResolver) ResetEmployerPassword(ctx context.Context, newPassword string) (*model.Employer, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	user, err := auth.ForContext(ctx)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, errors.New("access to reset employer password denied!")
	}
	role := user.GetRole()
	if role != "employer" {
		return nil, errors.New("access to reset employer password denied. Only available for registered and logged in employers. To fix check access token!")
	}
	id, err := user.GetID()

	if err != nil {
		errors.New("could not access employer's id!")
	}

	//validate inputs
	if err := validate.ValidatePassword(newPassword); err != nil {
		return nil, err
	}

	var employer *model.Employer
	//fetch the record to be updated from the database
	if err := r.Sql.Db.First(&employer, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "ResetEmployerPassword").Msg(err.Error())
		return nil, err
	}
	//encrypt input password
	encryptedpassword, err := encrypt.HashPassword(newPassword)
	if err != nil {
		log.Error().Str("password", newPassword).Str("path", "ResetEmployerPassword").Msg(err.Error())
		return nil, err
	}
	// Update the records' attributes with `map`
	if err := r.Sql.Db.Model(&employer).Updates(map[string]interface{}{"password": encryptedpassword}).Error; err != nil {
		log.Error().Int("id", employer.ID).Str("path", "ResetEmployerPassword").Msg(fmt.Sprintf("updating employer password failed: %s", err.Error()))
		return nil, err
	}

	//fetch the record again from the database, this time the updated version
	if err := r.Sql.Db.First(&employer, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "ResetEmployerPassword").Msg(err.Error())
		return nil, err
	}

	//return the updated record
	return employer, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input *model.RefreshTokenInput) (*string, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	credentials, err := jwt.ParseToken(input.Token)
	if err != nil {
		return nil, fmt.Errorf("access denied")
	}
	token, error := jwt.GenerateToken(*credentials)
	if error != nil {
		log.Error().Str("id", credentials.Id).Str("role", credentials.Role).Str("path", "RefreshToken").Msg(err.Error())
		return nil, error
	}
	return &token, nil
}

// EditEmployerProfile is the resolver for the editEmployerProfile field.
func (r *mutationResolver) EditEmployerProfile(ctx context.Context, input model.UpdatedEmployer) (*model.EmployerProfile, error) {
	user, err := auth.ForContext(ctx)

	if err != nil {
		return nil, err
	}

	id, err := user.GetID()

	if err != nil {
		errors.New("could not access employer's id!")
	}

	//declare an employer variable
	var employer *model.Employer

	//Find the first employer that matches the input id
	if err := r.Sql.Db.Where("id = ?", id).First(&employer).Error; err != nil {
		log.Info().Int("id", id).Str("path", "EditEmployerProfile").Msg("id does not exist")
		return nil, errors.New("error finding employer with id: " + strconv.Itoa(id))
	}

	employer.Name = input.Name
	employer.PhoneNumber = input.PhoneNumber
	employer.Badge = input.Badge
	employer.Website = input.Website

	// Update employer record
	if err := r.Sql.Db.Save(&employer).Error; err != nil {
		log.Info().Int("id", id).Str("path", "EditEmployerProfile").Msg("failed to update employer")
		return nil, errors.New("error updating employer with id: " + strconv.Itoa(id))
	}

	employerprofile := &model.EmployerProfile{
		ID:          employer.ID,
		CreatedAt:   employer.CreatedAt,
		UpdatedAt:   employer.UpdatedAt,
		Name:        employer.Name,
		PhoneNumber: employer.PhoneNumber,
		Badge:       employer.Badge,
		Website:     employer.Website,
	}

	return employerprofile, nil
}

// EmployerPhoneNumberExists is the resolver for the employerPhoneNumberExists field, checks if an employer's phone number already exists in both the unverified_employers and employers tables
func (r *queryResolver) EmployerPhoneNumberExists(ctx context.Context, phoneNumber string) (*model.PhoneNumberExists, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	phoneexists, err := phoneutils.CheckEmployerPhoneNumber(r.Sql.Db, phoneNumber)

	if err != nil {
		log.Error().Str("phone_number", phoneNumber).Str("path", "EmployerPhoneNumberExists").Msg(err.Error())
		return nil, err
	}

	return phoneexists, nil
}

// GetEmployerProfile is the resolver for the getEmployerProfile field.
func (r *queryResolver) GetEmployerProfile(ctx context.Context) (*model.EmployerProfile, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}
	user, err := auth.ForContext(ctx)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, errors.New("access to getEmployer profile denied!")
	}
	role := user.GetRole()
	if role != "employer" {
		return nil, errors.New("access to getEmployer profile denied. Only available for registered and logged in employers. To fix check access token!")
	}
	id, err := user.GetID()

	if err != nil {
		errors.New("could not access employer's id!")
	}

	var employer *model.Employer
	if err := r.Sql.Db.First(&employer, id).Error; err != nil {
		log.Error().Int("id", id).Str("path", "GetEmployerProfile").Msg(err.Error())
		return nil, errors.New("could not access employer's profile!")
	}
	log.Info().Int("id", id).Str("role", role).Str("path", "GetEmployerProfile").Msg("getting employer's profile")
	employerprofile := &model.EmployerProfile{
		ID:          employer.ID,
		CreatedAt:   employer.CreatedAt,
		UpdatedAt:   employer.UpdatedAt,
		Name:        employer.Name,
		PhoneNumber: employer.PhoneNumber,
		Badge:       employer.Badge,
		Website:     employer.Website,
	}
	return employerprofile, nil
}

// GetEmployersProfile is the resolver for the getEmployersProfile field.
func (r *queryResolver) GetEmployersProfile(ctx context.Context) ([]*model.EmployerProfile, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	var employers []*model.Employer
	if err := r.Sql.Db.Find(&employers).Error; err != nil {
		log.Error().Str("path", "GetEmployersProfile").Msg(err.Error())
		return nil, errors.New("could not access employers' profile!")
	}
	log.Info().Str("path", "GetEmployersProfile").Msg("getting employers' profile")

	var employersprofile []*model.EmployerProfile

	for _, employer := range employers {
		employerprofile := &model.EmployerProfile{
			ID:          employer.ID,
			CreatedAt:   employer.CreatedAt,
			UpdatedAt:   employer.UpdatedAt,
			Name:        employer.Name,
			PhoneNumber: employer.PhoneNumber,
			Badge:       employer.Badge,
			Website:     employer.Website,
		}
		employersprofile = append(employersprofile, employerprofile)
	}

	return employersprofile, nil
}

// FindEmployer is the resolver for the findEmployer field.
func (r *queryResolver) FindEmployer(ctx context.Context, id int) (*model.EmployerProfile, error) {
	//check if system is in shutdown mode
	if *shutdown.IsShutdown {
		return nil, errors.New("System is shut down for maintainance. We are sorry for any incoveniences caused")
	}

	//declare an employer variable
	var employer *model.Employer

	// Find the first employer that matches the input id from the employer table
	if err := r.Sql.Db.Where("id = ?", id).First(&employer).Error; err != nil {
		log.Info().Int("id", id).Str("path", "FindEmployer").Msg("id does not exist")
		return nil, errors.New("error finding employer with id: " + strconv.Itoa(id))
	}

	employerprofile := &model.EmployerProfile{
		ID:          employer.ID,
		CreatedAt:   employer.CreatedAt,
		UpdatedAt:   employer.UpdatedAt,
		Name:        employer.Name,
		PhoneNumber: employer.PhoneNumber,
		Badge:       employer.Badge,
		Website:     employer.Website,
	}

	return employerprofile, nil
}

// EmployerProfile returns EmployerProfileResolver implementation.
func (r *Resolver) EmployerProfile() EmployerProfileResolver { return &employerProfileResolver{r} }

type employerProfileResolver struct{ *Resolver }
